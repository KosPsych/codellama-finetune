  public void testSimple() {
    quickfixTest("<warning descr=\"Redundant character escape '\\;' in RegExp\">\\;</warning>", ";", "Remove redundant escape");
  }
###END###
  public void testCharacterClass() {
    highlightTest("<warning descr=\"Redundant character escape '\\-' in RegExp\">\\-</warning>[<warning descr=\"Redundant character escape '\\*' in RegExp\">\\*</warning>\\-\\[\\]\\\\<warning descr=\"Redundant character escape '\\+' in RegExp\">\\+</warning>]");
  }
###END###
  public void testWhitespace() {
    highlightTest("a<warning descr=\"Redundant character escape '\\ ' in RegExp\">\\ </warning>b<warning descr=\"Redundant character escape '\\ ' in RegExp\">\\ </warning>c");
  }
###END###
  public void testEscapedU() {
    quickfixTest("<warning descr=\"Redundant character escape '\\u' in RegExp\">\\u</warning>", "u", "Remove redundant escape",
                 RegExpFileType.forLanguage(EcmaScriptRegexpLanguage.INSTANCE));
  }
###END###
  public void testPoundSign() {
    highlightTest("<warning descr=\"Redundant character escape '\\#' in RegExp\">\\#</warning>(?x)\\#");
  }
###END###
  public void testCurlyBrace() {
    highlightTest("\\{TEST}", RegExpFileType.forLanguage(EcmaScriptRegexpLanguage.INSTANCE));
  }
###END###
  protected LocalInspectionTool getInspection() {
    return new RegExpRedundantEscapeInspection();
  }
###END###
  public void testSimple() {
    quickfixTest("<warning descr=\"Octal escape '\\011' in RegExp\">\\011</warning>", "\\x09", "Replace with '\\x09'");
  }
###END###
  protected LocalInspectionTool getInspection() {
    return new OctalEscapeInspection();
  }
###END###
  public void testSimple() {
    quickfixTest("abc <warning descr=\"Unnecessary non-capturing group '(?:def)'\"><caret>(?:</warning>def) ghi",
                 "abc def ghi",
                 RegExpBundle.message("inspection.quick.fix.remove.unnecessary.non.capturing.group"));
  }
###END###
  public void testNoWarnOnRegularGroup() {
    highlightTest("abc (def) ghi");
  }
###END###
  public void testNoWarnOnAlternation() {
    highlightTest("aa(?:bb|bbb)cccc");
  }
###END###
  public void testNoNonCapturingGroupWarnOnEmptyGroup() {
    highlightTest("<warning descr=\"Empty group\">(?:)</warning>");
  }
###END###
  public void testNoWarnOnNestedClosure() {
    highlightTest("\\d{2}(?:\\d{3})?");
    highlightTest("\\d{2}(?:\\d{3}){2}");
    highlightTest("\\d{2}(?:\\d{3})+");
    highlightTest("\\d{2}(?:\\d{3})*");
  }
###END###
  public void testTopLevelAlternation() {
    quickfixTest("<warning descr=\"Unnecessary non-capturing group '(?:xx|xy)'\">(?:</warning>xx|xy)", "xx|xy",
                 RegExpBundle.message("inspection.quick.fix.remove.unnecessary.non.capturing.group"));
  }
###END###
  public void testSingleAtom() {
    quickfixTest("aaa<warning descr=\"Unnecessary non-capturing group '(?:b)'\">(?:<caret></warning>b)+aaa",
                 "aaab+aaa",
                 RegExpBundle.message("inspection.quick.fix.remove.unnecessary.non.capturing.group"));
  }
###END###
  public void testCorrectEscaping() {
    quickfixTest("<warning descr=\"Unnecessary non-capturing group '(?:[\\w-]+:)'\"><caret>(?:</warning>[\\w-]+:)[\\w-]+",
                 "[\\w-]+:[\\w-]+",
                 RegExpBundle.message("inspection.quick.fix.remove.unnecessary.non.capturing.group"));
  }
###END###
  protected @NotNull LocalInspectionTool getInspection() {
    return new UnnecessaryNonCapturingGroupInspection();
  }
###END###
  public void testPredefinedCharacterClass() {
    quickfixTest("[\\w-<warning descr=\"Duplicate predefined character class '\\w' inside character class\"><caret>\\w</warning>]",
                 "[\\w-]", RegExpBundle.message("inspection.quick.fix.remove.duplicate.0.from.character.class", "\\w"));
  }
###END###
  public void testQuoted() {
    highlightTest("[\\Qabc?*+.)<warning descr=\"Duplicate character ')' inside character class\">)</warning>]<warning descr=\"Duplicate character ']' inside character class\">]</warning>[<warning descr=\"Duplicate character ']' inside character class\">]</warning></w<warning descr=\"Duplicate character 'a' inside character class\">a</warning>rni<warning descr=\"Duplicate character 'n' inside character class\">n</warning>g>\\E]");
  }
###END###
  public void testNotPosixCharacterClass() {
    highlightTest("[:xdig<warning descr=\"Duplicate character 'i' inside character class\">i</warning>t<warning descr=\"Duplicate character ':' inside character class\">:</warning>]+");
  }
###END###
  public void testSpace() {
    quickfixAllTest("[ <warning descr=\"Duplicate character ' ' inside character class\"><caret> </warning><warning descr=\"Duplicate character ' ' inside character class\"> </warning>]", "[ ]");
  }
###END###
  public void testNegatedClass() {
    highlightTest("[^a<warning descr=\"Duplicate character 'a' inside character class\">a</warning>]");
  }
###END###
  public void testNestedClass() {
    highlightTest("[<[^<>]*>]*<[^<>]*");
  }
###END###
  protected @NotNull LocalInspectionTool getInspection() {
    return new DuplicateCharacterInClassInspection();
  }
###END###
  public void parseLight(IElementType root, PsiBuilder builder) {
    final PsiBuilder.Marker rootMarker = builder.mark();

    while (true) {
      parsePattern(builder);
      if (builder.eof()) break;
      patternExpected(builder);
      if (builder.eof()) break;
    }

    rootMarker.done(root);
  }
###END###
  public ASTNode parse(@NotNull IElementType root, @NotNull PsiBuilder builder) {
    parseLight(root, builder);
    return builder.getTreeBuilt();
  }
###END###
  protected void parsePattern(PsiBuilder builder) {
    final PsiBuilder.Marker marker = builder.mark();

    parseBranch(builder);

    while (builder.getTokenType() == RegExpTT.UNION) {
      builder.advanceLexer();
      parseBranch(builder);
    }

    marker.done(RegExpElementTypes.PATTERN);
  }
###END###
  private void parseBranch(PsiBuilder builder) {
    final PsiBuilder.Marker marker = builder.mark();

    while (!parseAtom(builder)) {
      final IElementType token = builder.getTokenType();
      if (token == RegExpTT.GROUP_END || token == RegExpTT.UNION || token == null) {
        // empty branches are allowed
        marker.done(RegExpElementTypes.BRANCH);
        return;
      }
      patternExpected(builder);
    }

    //noinspection StatementWithEmptyBody
    while (parseAtom(builder)) {}

    marker.done(RegExpElementTypes.BRANCH);
  }
###END###
  private boolean parseAtom(PsiBuilder builder) {
    final PsiBuilder.Marker marker = parseGroup(builder);

    if (marker == null) {
      return false;
    }
    final PsiBuilder.Marker marker2 = marker.precede();

    if (parseQuantifier(builder)) {
      marker2.done(RegExpElementTypes.CLOSURE);
    }
    else {
      marker2.drop();
    }

    return true;
  }
###END###
  private boolean parseQuantifier(PsiBuilder builder) {
    final PsiBuilder.Marker marker = builder.mark();

    if (builder.getTokenType() == RegExpTT.LBRACE) {
      builder.advanceLexer();
      final boolean minOmitted = builder.getTokenType() == RegExpTT.COMMA &&
                                 myCapabilities.contains(RegExpCapability.OMIT_NUMBERS_IN_QUANTIFIERS);
      if (minOmitted) {
        builder.advanceLexer();
      }
      else {
        if (builder.getTokenType() == RegExpTT.NUMBER) {
          final PsiBuilder.Marker numberMark = builder.mark();
          builder.advanceLexer();
          numberMark.done(RegExpElementTypes.NUMBER);
        }
        else {
          builder.error(RegExpBundle.message("parse.error.number.expected"));
        }
      }
      if (builder.getTokenType() == RegExpTT.RBRACE) {
        builder.advanceLexer();
        parseQuantifierType(builder);
        marker.done(RegExpElementTypes.QUANTIFIER);
      }
      else {
        if (!minOmitted) {
          checkMatches(builder, RegExpTT.COMMA, RegExpBundle.message("parse.error.comma.expected"));
        }
        if (builder.getTokenType() == RegExpTT.RBRACE) {
          builder.advanceLexer();
          parseQuantifierType(builder);
          marker.done(RegExpElementTypes.QUANTIFIER);
        }
        else if (builder.getTokenType() == RegExpTT.NUMBER) {
          final PsiBuilder.Marker numberMark = builder.mark();
          builder.advanceLexer();
          numberMark.done(RegExpElementTypes.NUMBER);
          checkMatches(builder, RegExpTT.RBRACE, RegExpBundle.message("parse.error.closing.brace.expected"));
          parseQuantifierType(builder);
          marker.done(RegExpElementTypes.QUANTIFIER);
        }
        else {
          builder.error(RegExpBundle.message("parse.error.closing.brace.or.number.expected"));
          marker.done(RegExpElementTypes.QUANTIFIER);
          return true;
        }
      }
    }
    else if (RegExpTT.QUANTIFIERS.contains(builder.getTokenType())) {
      builder.advanceLexer();
      parseQuantifierType(builder);
      marker.done(RegExpElementTypes.QUANTIFIER);
    }
    else {
      marker.drop();
      return false;
    }

    return true;
  }
###END###
  private static void parseQuantifierType(PsiBuilder builder) {
    if (builder.getTokenType() == RegExpTT.PLUS || builder.getTokenType() == RegExpTT.QUEST) {
      builder.advanceLexer();
    }
    else {
      if (RegExpTT.QUANTIFIERS.contains(builder.getTokenType())) {
        builder.error(RegExpBundle.message("error.dangling.metacharacter", builder.getTokenText()));
      }
    }
  }
###END###
  private PsiBuilder.Marker parseClass(PsiBuilder builder) {
    final PsiBuilder.Marker marker = builder.mark();
    builder.advanceLexer();

    if (builder.getTokenType() == RegExpTT.CARET) {
      builder.advanceLexer();
    }
    parseClassIntersection(builder);

    checkMatches(builder, RegExpTT.CLASS_END, RegExpBundle.message("parse.error.unclosed.character.class"));
    marker.done(RegExpElementTypes.CLASS);
    return marker;
  }
###END###
  private void parseClassIntersection(PsiBuilder builder) {
    final PsiBuilder.Marker marker = builder.mark();

    boolean left = parseClassdef(builder);
    if (RegExpTT.ANDAND != builder.getTokenType()) {
      marker.drop();
      return;
    }
    while (RegExpTT.ANDAND == builder.getTokenType()) {
      builder.advanceLexer();
      final boolean right = parseClassdef(builder);
      if (!left && !right) {
        builder.error(RegExpBundle.message("parse.error.character.class.expected"));
      }
      left = right;
    }
    marker.done(RegExpElementTypes.INTERSECTION);
  }
###END###
  private boolean parseClassdef(PsiBuilder builder) {
    int count = 0;
    while (true) {
      final IElementType token = builder.getTokenType();
      if (token == RegExpTT.CLASS_BEGIN) {
        parseClass(builder);
      }
      else if (token == RegExpTT.BRACKET_EXPRESSION_BEGIN) {
        parseBracketExpression(builder);
      }
      else if (token == RegExpTT.MYSQL_CHAR_BEGIN) {
        parseMysqlCharExpression(builder);
      }
      else if (token == RegExpTT.MYSQL_CHAR_EQ_BEGIN) {
        parseMysqlCharEqExpression(builder);
      }
      else if (RegExpTT.CHARACTERS.contains(token) || token == RegExpTT.NAMED_CHARACTER) {
        parseCharacterRange(builder);
      }
      else if (token == RegExpTT.CHAR_CLASS) {
        final PsiBuilder.Marker m = builder.mark();
        builder.advanceLexer();
        m.done(RegExpElementTypes.SIMPLE_CLASS);
      }
      else if (token == RegExpTT.PROPERTY) {
        parseProperty(builder);
      }
      else {
        return count > 0;
      }
      count++;
    }
  }
###END###
  private static void parseBracketExpression(PsiBuilder builder) {
    final PsiBuilder.Marker marker = builder.mark();
    builder.advanceLexer();
    if (builder.getTokenType() == RegExpTT.CARET) {
      builder.advanceLexer();
    }
    checkMatches(builder, RegExpTT.NAME, RegExpBundle.message("parse.error.posix.character.class.name.expected"));
    checkMatches(builder, RegExpTT.BRACKET_EXPRESSION_END, RegExpBundle.message("parse.error.unclosed.posix.bracket.expression"));
    marker.done(RegExpElementTypes.POSIX_BRACKET_EXPRESSION);
  }
###END###
  private static void parseMysqlCharExpression(PsiBuilder builder) {
    final PsiBuilder.Marker marker = builder.mark();
    builder.advanceLexer();
    if (builder.getTokenType() == RegExpTT.NAME) {
      builder.advanceLexer();
    }
    else {
      checkMatches(builder, RegExpTT.CHARACTER, RegExpBundle.message("parse.error.character.or.mysql.character.name.expected"));
    }
    checkMatches(builder, RegExpTT.MYSQL_CHAR_END, RegExpBundle.message("parse.error.unclosed.mysql.character.expression"));
    marker.done(RegExpElementTypes.MYSQL_CHAR_EXPRESSION);
  }
###END###
  private static void parseMysqlCharEqExpression(PsiBuilder builder) {
    final PsiBuilder.Marker marker = builder.mark();
    builder.advanceLexer();
    checkMatches(builder, RegExpTT.CHARACTER, RegExpBundle.message("parse.error.character.expected"));
    checkMatches(builder, RegExpTT.MYSQL_CHAR_EQ_END, RegExpBundle.message("parse.error.unclosed.mysql.character.equivalence.class"));
    marker.done(RegExpElementTypes.MYSQL_CHAR_EQ_EXPRESSION);
  }
###END###
  private void parseCharacterRange(PsiBuilder builder) {
    final PsiBuilder.Marker rangeMarker = builder.mark();
    parseCharacter(builder);

    if (builder.getTokenType() == RegExpTT.MINUS) {
      final PsiBuilder.Marker minusMarker = builder.mark();
      builder.advanceLexer();

      final IElementType t = builder.getTokenType();
      if (RegExpTT.CHARACTERS.contains(t) || t == RegExpTT.NAMED_CHARACTER) {
        minusMarker.drop();
        parseCharacter(builder);
        rangeMarker.done(RegExpElementTypes.CHAR_RANGE);
      }
      else {
        if (t == RegExpTT.CLASS_END) { // [a-]
          rangeMarker.drop();
          minusMarker.done(RegExpElementTypes.CHAR);
        }
        else if (t == RegExpTT.CLASS_BEGIN) { // [a-[b]]\
          rangeMarker.drop();
          minusMarker.done(RegExpElementTypes.CHAR);
          parseClassdef(builder);
        }
        else {
          minusMarker.drop();
          builder.error(RegExpBundle.message("parse.error.illegal.character.range"));
          rangeMarker.done(RegExpElementTypes.CHAR_RANGE);
        }
      }
    }
    else {
      rangeMarker.drop();
    }
  }
###END###
  private PsiBuilder.Marker parseGroup(PsiBuilder builder) {
    final IElementType type = builder.getTokenType();

    final PsiBuilder.Marker marker = builder.mark();

    if (RegExpTT.GROUPS.contains(type)) {
      builder.advanceLexer();
      parseGroupEnd(builder);
      marker.done(RegExpElementTypes.GROUP);
    }
    else if (type == RegExpTT.SET_OPTIONS) {
      builder.advanceLexer();

      if (builder.getTokenType() == RegExpTT.OPTIONS_ON) {
        final PsiBuilder.Marker o = builder.mark();
        builder.advanceLexer();
        o.done(RegExpElementTypes.OPTIONS);
      }
      if (builder.getTokenType() == RegExpTT.OPTIONS_OFF) {
        final PsiBuilder.Marker o = builder.mark();
        builder.advanceLexer();
        o.done(RegExpElementTypes.OPTIONS);
      }

      if (builder.getTokenType() == RegExpTT.COLON) {
        builder.advanceLexer();
        parseGroupEnd(builder);
        marker.done(RegExpElementTypes.GROUP);
      }
      else {
        checkMatches(builder, RegExpTT.GROUP_END, RegExpBundle.message("parse.error.unclosed.options.group"));
        marker.done(RegExpElementTypes.SET_OPTIONS);
      }
    }
    else if (RegExpTT.CHARACTERS.contains(type) || type == RegExpTT.NAMED_CHARACTER) {
      marker.drop();
      parseCharacter(builder);
    }
    else if (type == RegExpTT.NUMBER || type == RegExpTT.COMMA) {
      // don't show these as errors
      builder.remapCurrentToken(RegExpTT.CHARACTER);
      builder.advanceLexer();
      marker.done(RegExpElementTypes.CHAR);
    }
    else if (RegExpTT.BOUNDARIES.contains(type)) {
      builder.advanceLexer();
      marker.done(RegExpElementTypes.BOUNDARY);
    }
    else if (type == RegExpTT.BACKREF) {
      builder.advanceLexer();
      marker.done(RegExpElementTypes.BACKREF);
    }
    else if (type == RegExpTT.PYTHON_NAMED_GROUP || type == RegExpTT.RUBY_NAMED_GROUP || type == RegExpTT.RUBY_QUOTED_NAMED_GROUP) {
      builder.advanceLexer();
      checkMatches(builder, RegExpTT.NAME, RegExpBundle.message("parse.error.group.name.expected"));
      checkMatches(builder, type == RegExpTT.RUBY_QUOTED_NAMED_GROUP ? RegExpTT.QUOTE : RegExpTT.GT,
                   RegExpBundle.message("parse.error.unclosed.group.name"));
      parseGroupEnd(builder);
      marker.done(RegExpElementTypes.GROUP);
    }
    else if (type == RegExpTT.PYTHON_NAMED_GROUP_REF || type == RegExpTT.PCRE_RECURSIVE_NAMED_GROUP_REF) {
      parseNamedGroupRef(builder, marker, RegExpTT.GROUP_END);
    }
    else if (type == RegExpTT.PCRE_NUMBERED_GROUP_REF) {
      builder.advanceLexer();
      marker.done(RegExpElementTypes.BACKREF);
    }
    else if (type == RegExpTT.RUBY_NAMED_GROUP_REF || type == RegExpTT.RUBY_NAMED_GROUP_CALL) {
      parseNamedGroupRef(builder, marker, RegExpTT.GT);
    }
    else if (type == RegExpTT.RUBY_QUOTED_NAMED_GROUP_REF || type == RegExpTT.RUBY_QUOTED_NAMED_GROUP_CALL) {
      parseNamedGroupRef(builder, marker, RegExpTT.QUOTE);
    }
    else if (type == RegExpTT.CONDITIONAL) {
      builder.advanceLexer();
      parseCondition(builder);
      parseBranch(builder);
      if (builder.getTokenType() == RegExpTT.UNION) {
        builder.advanceLexer();
        parseBranch(builder);
      }
      if (!checkMatches(builder, RegExpTT.GROUP_END, RegExpBundle.message("parse.error.unclosed.group"))) {
        parseGroupEnd(builder);
      }
      marker.done(RegExpElementTypes.CONDITIONAL);
    }
    else if (type == RegExpTT.PROPERTY) {
      marker.drop();
      parseProperty(builder);
    }
    else if (type == RegExpTT.DOT || type == RegExpTT.CHAR_CLASS) {
      builder.advanceLexer();
      marker.done(RegExpElementTypes.SIMPLE_CLASS);
    }
    else if (type == RegExpTT.CLASS_BEGIN) {
      marker.drop();
      return parseClass(builder);
    }
    else {
      marker.drop();
      return null;
    }
    return marker;
  }
###END###
  private void parseCondition(PsiBuilder builder) {
    final IElementType type = builder.getTokenType();
    if (RegExpTT.LOOKAROUND_GROUPS.contains(type)) {
      final PsiBuilder.Marker marker = builder.mark();
      builder.advanceLexer();
      parseGroupEnd(builder);
      marker.done(RegExpElementTypes.GROUP);
    }
    else {
      if (RegExpTT.GROUP_BEGIN == type) {
        IElementType lookAhead = builder.lookAhead(1);
        if (RegExpTT.PCRE_CONDITIONS.contains(lookAhead)) {
          parsePcreConditionalGroup(builder);
        }
        else {
          parseGroupReferenceCondition(builder, RegExpTT.GROUP_END);
        }
      }
      else if (RegExpTT.QUOTED_CONDITION_BEGIN == type) {
        parseGroupReferenceCondition(builder, RegExpTT.QUOTED_CONDITION_END);
      }
      else if (RegExpTT.ANGLE_BRACKET_CONDITION_BEGIN == type) {
        parseGroupReferenceCondition(builder, RegExpTT.ANGLE_BRACKET_CONDITION_END);
      }
    }
  }
###END###
  private void parseGroupReferenceCondition(PsiBuilder builder, IElementType endToken) {
    final PsiBuilder.Marker marker = builder.mark();
    builder.advanceLexer();
    final IElementType next = builder.getTokenType();
    final Boolean named;
    if (next == RegExpTT.NAME) {
      builder.advanceLexer();
      named = true;
    }
    else if (next == RegExpTT.NUMBER) {
      builder.advanceLexer();
      named = false;
    }
    else {
      named = null;
      builder.error(RegExpBundle.message("parse.error.group.name.or.number.expected"));
      parsePattern(builder);
    }
    checkMatches(builder, endToken, RegExpBundle.message("parse.error.unclosed.group.reference"));
    if (named == Boolean.TRUE) {
      marker.done(RegExpElementTypes.NAMED_GROUP_REF);
    }
    else if (named == Boolean.FALSE) {
      marker.done(RegExpElementTypes.BACKREF);
    }
    else {
      marker.drop();
    }
  }
###END###
  private void parseGroupEnd(PsiBuilder builder) {
    parsePattern(builder);
    checkMatches(builder, RegExpTT.GROUP_END, RegExpBundle.message("parse.error.unclosed.group"));
  }
###END###
  private static void parsePcreConditionalGroup(PsiBuilder builder) {
    final PsiBuilder.Marker marker = builder.mark();
    builder.advanceLexer();
    builder.advanceLexer();
    checkMatches(builder, RegExpTT.GROUP_END, RegExpBundle.message("parse.error.unclosed.group.reference"));
    marker.done(RegExpElementTypes.GROUP);
  }
###END###
  private static void parseNamedGroupRef(PsiBuilder builder, PsiBuilder.Marker marker, IElementType type) {
    builder.advanceLexer();
    checkMatches(builder, RegExpTT.NAME, RegExpBundle.message("parse.error.group.name.expected"));
    checkMatches(builder, type, RegExpBundle.message("parse.error.unclosed.group.reference"));
    marker.done(RegExpElementTypes.NAMED_GROUP_REF);
  }
###END###
  private static boolean isLetter(CharSequence text) {
    if (text == null) return false;
    assert text.length() == 1;
    final char c = text.charAt(0);
    return AsciiUtil.isLetter(c);
  }
###END###
  private void parseProperty(PsiBuilder builder) {
    final PsiBuilder.Marker marker = builder.mark();
    builder.advanceLexer();
    if (builder.getTokenType() == RegExpTT.CATEGORY_SHORT_HAND) {
      if (!myCapabilities.contains(RegExpCapability.UNICODE_CATEGORY_SHORTHAND)) {
        builder.error(RegExpBundle.message("parse.error.category.shorthand.not.allowed.in.this.regular.expression.dialect"));
      }
      builder.advanceLexer();
    }
    else {
      if (builder.getTokenType() == RegExpTT.CHARACTER && isLetter(builder.getTokenText())) {
        builder.error(myCapabilities.contains(RegExpCapability.UNICODE_CATEGORY_SHORTHAND) ?
                      RegExpBundle.message("parse.error.illegal.category.shorthand") :
                      RegExpBundle.message("parse.error.opening.brace.expected"));
        builder.advanceLexer();
      }
      else if (checkMatches(builder, RegExpTT.LBRACE, myCapabilities.contains(RegExpCapability.UNICODE_CATEGORY_SHORTHAND) ?
                                                      RegExpBundle.message("parse.error.opening.brace.or.category.shorthand.expected") :
                                                      RegExpBundle.message("parse.error.opening.brace.expected"))) {
        if (builder.getTokenType() == RegExpTT.CARET) {
          if (!myCapabilities.contains(RegExpCapability.CARET_NEGATED_PROPERTIES)) {
            builder.error(RegExpBundle.message("parse.error.negating.a.property.not.allowed.in.this.regular.expression.dialect"));
          }
          builder.advanceLexer();
        }
        if (builder.getTokenType() == RegExpTT.NAME) {
          builder.advanceLexer(); //name
          if (myCapabilities.contains(RegExpCapability.PROPERTY_VALUES) && builder.getTokenType() == RegExpTT.EQ) {
            builder.advanceLexer(); //eq
            checkMatches(builder, RegExpTT.NAME, RegExpBundle.message("parse.error.property.value.expected"));
          }
          checkMatches(builder, RegExpTT.RBRACE, RegExpBundle.message("parse.error.unclosed.property"));
        }
        else
        {
          if (builder.getTokenType() == RegExpTT.RBRACE) {
            builder.error(RegExpBundle.message("parse.error.empty.property"));
            builder.advanceLexer();
          }
          else {
            builder.error(RegExpBundle.message("parse.error.property.name.expected"));
          }
          while (PROPERTY_TOKENS.contains(builder.getTokenType())) {
            builder.advanceLexer();
          }
        }
      }
    }
    marker.done(RegExpElementTypes.PROPERTY);
  }
###END###
  private static void parseCharacter(PsiBuilder builder) {
    final PsiBuilder.Marker marker = builder.mark();
    if (builder.getTokenType() == RegExpTT.NAMED_CHARACTER) {
      builder.advanceLexer();
      checkMatches(builder, RegExpTT.LBRACE, RegExpBundle.message("parse.error.opening.brace.expected"));
      checkMatches(builder, RegExpTT.NAME, RegExpBundle.message("parse.error.unicode.character.name.expected"));
      checkMatches(builder, RegExpTT.RBRACE, RegExpBundle.message("parse.error.closing.brace.expected"));
      marker.done(RegExpElementTypes.NAMED_CHARACTER);
    }
    else if (builder.getTokenType() == RegExpTT.UNICODE_CHAR) {
      final String text1 = builder.getTokenText();
      assert text1 != null;
      final int value1 = RegExpCharImpl.unescapeChar(text1);
      builder.advanceLexer();
      // merge surrogate pairs into single regexp char
      if (!Character.isSupplementaryCodePoint(value1) && Character.isHighSurrogate((char)value1)) {
        final String text2 = builder.getTokenText();
        if (text2 != null) {
          final int value2 = RegExpCharImpl.unescapeChar(text2);
          if (!Character.isSupplementaryCodePoint(value2) && Character.isLowSurrogate((char)value2)) {
            builder.advanceLexer();
          }
        }
      }
      marker.done(RegExpElementTypes.CHAR);
    }
    else {
      builder.advanceLexer();
      marker.done(RegExpElementTypes.CHAR);
    }
  }
###END###
  private static void patternExpected(PsiBuilder builder) {
    final IElementType token = builder.getTokenType();
    if (token == RegExpTT.GROUP_END || token == RegExpTT.RBRACE || token == RegExpTT.CLASS_END) {
      builder.error(RegExpBundle.message("parse.error.unmatched.closing.bracket", builder.getTokenText()));
    }
    else if (token == RegExpTT.LBRACE) {
      builder.error(RegExpBundle.message("error.dangling.opening.bracket"));
      // try to recover
      builder.advanceLexer();
      while (builder.getTokenType() == RegExpTT.NUMBER || builder.getTokenType() == RegExpTT.COMMA) {
        builder.advanceLexer();
      }
      if (builder.getTokenType() == RegExpTT.RBRACE) {
        builder.advanceLexer();
      }
    }
    else if (RegExpTT.QUANTIFIERS.contains(token)) {
      builder.error(RegExpBundle.message("error.dangling.metacharacter", builder.getTokenText()));
    }
    else {
      builder.error(RegExpBundle.message("parse.error.pattern.expected"));
    }
    builder.advanceLexer();
  }
###END###
  protected static boolean checkMatches(final PsiBuilder builder, final IElementType token, @NotNull @NlsContexts.ParsingError String message) {
    if (builder.getTokenType() == token) {
      builder.advanceLexer();
      return true;
    }
    else {
      builder.error(message);
      return false;
    }
  }
###END###
  public void add(int start, int end) {
    groups.add(start);
    groups.add(end);
  }
###END###
  public int count() {
    return groups.size() / 2;
  }
###END###
  public int start(int i) {
    if (i < 0 || i > count() - 1) throw new IllegalArgumentException();

    return groups.getInt(i * 2);
  }
###END###
  public int end(int i) {
    if (i < 0 || i > count() - 1) throw new IllegalArgumentException();

    return groups.getInt(i * 2 + 1);
  }
###END###
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;

    return groups.equals(((RegExpMatch)o).groups);
  }
###END###
  public int hashCode() {
    return groups.hashCode();
  }
###END###
  public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append("RegExpMatch{");
    final int max = groups.size();
    for (int i = 0; i < max; i += 2) {
      builder.append('[').append(groups.getInt(i)).append(", ").append(groups.getInt(i + 1)).append(']');
    }
    builder.append('}');
    return builder.toString();
  }
###END###
  public static boolean isUpperCase(char c) {
    return c >= 'A' && c <= 'Z';
  }
###END###
  public static boolean isLowerCase(char c) {
    return c >= 'a' && c <= 'z';
  }
###END###
  public static boolean isLetter(char c) {
    return isUpperCase(c) || isLowerCase(c);
  }
###END###
  public static boolean isDigit(char c) {
    return c >= '0' && c <= '9';
  }
###END###
  public static boolean isLetterOrDigit(char c) {
    return isLetter(c) || isDigit(c);
  }
###END###
  private static void addLookupElement(final CompletionResultSet result, @NonNls final String name, String type, Icon icon) {
    result.addElement(createLookupElement(name, type, icon));
  }
###END###
  private static LookupElement createLookupElement(String name, String type, Icon icon) {
    return LookupElementBuilder.create(name).withTypeText(type).withIcon(icon);
  }
###END###
    protected void addCompletions(@NotNull CompletionParameters parameters,
                                  @NotNull ProcessingContext context,
                                  @NotNull CompletionResultSet result) {

      for (String[] completion : RegExpLanguageHosts.getInstance().getPosixCharacterClasses(parameters.getPosition())) {
        result.addElement(
          LookupElementBuilder.create(completion[0]).withTypeText((completion.length > 1) ? completion[1] : null).withIcon(emptyIcon)
            .withInsertHandler(new InsertHandler<>() {
              @Override
              public void handleInsert(@NotNull InsertionContext context, @NotNull LookupElement item) {
                context.setAddCompletionChar(false);
                final Editor editor = context.getEditor();
                final Document document = editor.getDocument();
                final int tailOffset = context.getTailOffset();
                if (document.getTextLength() < tailOffset + 2 ||
                    !document.getText(new TextRange(tailOffset, tailOffset + 2)).equals(":]")) {
                  document.insertString(tailOffset, ":]");
                }
                editor.getCaretModel().moveCaretRelatively(2, 0, false, false, true);
              }
            }));
      }
    }
###END###
              public void handleInsert(@NotNull InsertionContext context, @NotNull LookupElement item) {
                context.setAddCompletionChar(false);
                final Editor editor = context.getEditor();
                final Document document = editor.getDocument();
                final int tailOffset = context.getTailOffset();
                if (document.getTextLength() < tailOffset + 2 ||
                    !document.getText(new TextRange(tailOffset, tailOffset + 2)).equals(":]")) {
                  document.insertString(tailOffset, ":]");
                }
                editor.getCaretModel().moveCaretRelatively(2, 0, false, false, true);
              }
###END###
    public void addCompletions(@NotNull final CompletionParameters parameters,
                               @NotNull final ProcessingContext context,
                               @NotNull final CompletionResultSet result) {
      for (String[] stringArray : RegExpLanguageHosts.getInstance().getAllKnownProperties(parameters.getPosition())) {
        addLookupElement(result, "{" + stringArray[0] + "}", stringArray.length > 1 ? stringArray[1]:null, PlatformIcons.PROPERTY_ICON);
      }
    }
###END###
    public void addCompletions(@NotNull final CompletionParameters parameters,
                               @NotNull final ProcessingContext context,
                               @NotNull final CompletionResultSet result)
    {
      for (final String[] completion : RegExpLanguageHosts.getInstance().getKnownCharacterClasses(parameters.getPosition())) {
        addLookupElement(result, completion[0], completion[1], emptyIcon);
      }

      for (String[] stringArray : RegExpLanguageHosts.getInstance().getAllKnownProperties(parameters.getPosition())) {
        addLookupElement(result, "p{" + stringArray[0] + "}", stringArray.length > 1? stringArray[1]:null, PlatformIcons.PROPERTY_ICON);
      }
    }
###END###
    protected void addCompletions(@NotNull CompletionParameters parameters,
                                  @NotNull ProcessingContext context,
                                  @NotNull CompletionResultSet result) {
      UnicodeCharacterNames.iterate(name -> {
        if (result.getPrefixMatcher().prefixMatches(name)) {
          final String type = new String(new int[] {UnicodeCharacterNames.getCodePoint(name)}, 0, 1);
          if (myEmbrace) {
            result.addElement(createLookupElement("{" + name + "}", type, emptyIcon));
          }
          else {
            result.addElement(TailTypeDecorator.withTail(createLookupElement(name, type, emptyIcon), TailType.createSimpleTailType('}')));
          }
        }
        ProgressManager.checkCanceled();
      }
###END###
    protected void addCompletions(@NotNull CompletionParameters parameters,
                                  @NotNull ProcessingContext context,
                                  @NotNull CompletionResultSet result) {
      RegExpProperty property = ObjectUtils.tryCast(parameters.getPosition().getParent(), RegExpProperty.class);
      ASTNode propertyNameNode = property != null ? property.getCategoryNode() : null;
      if (propertyNameNode == null) {
        return;
      }
      for (String[] value : RegExpLanguageHosts.getInstance().getAllPropertyValues(property, propertyNameNode.getText())) {
        addLookupElement(result, value[0], value.length > 1 ? value[1] : null, null);
      }
    }
###END###
    protected void addCompletions(@NotNull CompletionParameters parameters,
                                  @NotNull ProcessingContext context,
                                  @NotNull CompletionResultSet result) {

      for (String[] completion : RegExpLanguageHosts.getInstance().getPosixCharacterClasses(parameters.getPosition())) {
        result.addElement(
          LookupElementBuilder.create(completion[0]).withTypeText((completion.length > 1) ? completion[1] : null).withIcon(emptyIcon)
            .withInsertHandler(new InsertHandler<>() {
              @Override
              public void handleInsert(@NotNull InsertionContext context, @NotNull LookupElement item) {
                context.setAddCompletionChar(false);
                final Editor editor = context.getEditor();
                final Document document = editor.getDocument();
                final int tailOffset = context.getTailOffset();
                if (document.getTextLength() < tailOffset + 2 ||
                    !document.getText(new TextRange(tailOffset, tailOffset + 2)).equals(":]")) {
                  document.insertString(tailOffset, ":]");
                }
                editor.getCaretModel().moveCaretRelatively(2, 0, false, false, true);
              }
            }));
      }
    }
###END###
              public void handleInsert(@NotNull InsertionContext context, @NotNull LookupElement item) {
                context.setAddCompletionChar(false);
                final Editor editor = context.getEditor();
                final Document document = editor.getDocument();
                final int tailOffset = context.getTailOffset();
                if (document.getTextLength() < tailOffset + 2 ||
                    !document.getText(new TextRange(tailOffset, tailOffset + 2)).equals(":]")) {
                  document.insertString(tailOffset, ":]");
                }
                editor.getCaretModel().moveCaretRelatively(2, 0, false, false, true);
              }
###END###
    public void addCompletions(@NotNull final CompletionParameters parameters,
                               @NotNull final ProcessingContext context,
                               @NotNull final CompletionResultSet result) {
      for (String[] stringArray : RegExpLanguageHosts.getInstance().getAllKnownProperties(parameters.getPosition())) {
        addLookupElement(result, "{" + stringArray[0] + "}", stringArray.length > 1 ? stringArray[1]:null, PlatformIcons.PROPERTY_ICON);
      }
    }
###END###
    public void addCompletions(@NotNull final CompletionParameters parameters,
                               @NotNull final ProcessingContext context,
                               @NotNull final CompletionResultSet result)
    {
      for (final String[] completion : RegExpLanguageHosts.getInstance().getKnownCharacterClasses(parameters.getPosition())) {
        addLookupElement(result, completion[0], completion[1], emptyIcon);
      }

      for (String[] stringArray : RegExpLanguageHosts.getInstance().getAllKnownProperties(parameters.getPosition())) {
        addLookupElement(result, "p{" + stringArray[0] + "}", stringArray.length > 1? stringArray[1]:null, PlatformIcons.PROPERTY_ICON);
      }
    }
###END###
    protected void addCompletions(@NotNull CompletionParameters parameters,
                                  @NotNull ProcessingContext context,
                                  @NotNull CompletionResultSet result) {
      UnicodeCharacterNames.iterate(name -> {
        if (result.getPrefixMatcher().prefixMatches(name)) {
          final String type = new String(new int[] {UnicodeCharacterNames.getCodePoint(name)}, 0, 1);
          if (myEmbrace) {
            result.addElement(createLookupElement("{" + name + "}", type, emptyIcon));
          }
          else {
            result.addElement(TailTypeDecorator.withTail(createLookupElement(name, type, emptyIcon), TailType.createSimpleTailType('}')));
          }
        }
        ProgressManager.checkCanceled();
      }
###END###
    protected void addCompletions(@NotNull CompletionParameters parameters,
                                  @NotNull ProcessingContext context,
                                  @NotNull CompletionResultSet result) {
      RegExpProperty property = ObjectUtils.tryCast(parameters.getPosition().getParent(), RegExpProperty.class);
      ASTNode propertyNameNode = property != null ? property.getCategoryNode() : null;
      if (propertyNameNode == null) {
        return;
      }
      for (String[] value : RegExpLanguageHosts.getInstance().getAllPropertyValues(property, propertyNameNode.getText())) {
        addLookupElement(result, value[0], value.length > 1 ? value[1] : null, null);
      }
    }
###END###
  public ASTNode getNameNode() {
    return getNode().findChildByType(RegExpTT.NAME);
  }
###END###
  public String getName() {
    final ASTNode node = getNameNode();
    return (node == null) ? null : node.getText();
  }
###END###
  public void accept(RegExpElementVisitor visitor) {
    visitor.visitRegExpNamedCharacter(this);
  }
###END###
  public void accept(RegExpElementVisitor visitor) {
    visitor.visitPosixBracketExpression(this);
  }
###END###
  public String getClassName() {
    final ASTNode nameNode = getNode().findChildByType(RegExpTT.NAME);
    return nameNode != null ? nameNode.getText() : null;
  }
###END###
    public Language getLanguage() {
        return RegExpLanguage.INSTANCE;
    }
###END###
  public String toString() {
        return getClass().getSimpleName() + ": <" + getText() + ">";
    }
###END###
    public void accept(@NotNull PsiElementVisitor visitor) {
        if (visitor instanceof RegExpElementVisitor) {
            accept((RegExpElementVisitor)visitor);
        } else {
            super.accept(visitor);
        }
    }
###END###
    public abstract void accept(RegExpElementVisitor visitor);

    @Override
    public PsiElement replace(@NotNull PsiElement psiElement) throws IncorrectOperationException {
        final ASTNode node = psiElement.getNode();
        assert node != null;
        getNode().getTreeParent().replaceChild(getNode(), node);
        return psiElement;
    }
###END###
    public PsiElement replace(@NotNull PsiElement psiElement) throws IncorrectOperationException {
        final ASTNode node = psiElement.getNode();
        assert node != null;
        getNode().getTreeParent().replaceChild(getNode(), node);
        return psiElement;
    }
###END###
    public void delete() throws IncorrectOperationException {
        getNode().getTreeParent().removeChild(getNode());
    }
###END###
    public final String getUnescapedText() {
        return InjectedLanguageManager.getInstance(getProject()).getUnescapedText(this);
    }
###END###
  public static boolean isLiteralExpression(@Nullable PsiElement context) {
    if (context == null) return false;
    ASTNode astNode = context.getNode();
    if (astNode == null) {
      return false;
    }
    ASTNode child = null;
    if (astNode instanceof CompositeElement) { // in some languages token nodes are wrapped within a single-child composite
      ASTNode[] children = astNode.getChildren(null);
      if (children.length == 1) {
        child = children[0];
      }
    }
    final ParserDefinition parserDefinition = LanguageParserDefinitions.INSTANCE.forLanguage(context.getLanguage());
    final TokenSet literalElements = parserDefinition.getStringLiteralElements();
    return literalElements.contains(astNode.getElementType()) || child != null && literalElements.contains(child.getElementType());
  }
###END###
