  public void testSelectWordSkipChar() {
    doTest("graafm<caret>achine",
           "<selection>graafmachine</selection>");
  }
###END###
  public void testSelectHexChar() {
    doTest("graafm\\x<caret>61chine",
           "graafm\\<selection>x61</selection>chine",
           "graafm<selection>\\x61</selection>chine",
           "<selection>graafm\\x61chine</selection>");
  }
###END###
  public void testSelectOctalChar() {
    doTest("graafm\\01<caret>4chine",
           "graafm\\<selection>014</selection>chine",
           "graafm<selection>\\014</selection>chine",
           "<selection>graafm\\014chine</selection>");
  }
###END###
  public void testSelectUnicodeEscape() {
    doTest("graafm\\u0<caret>061chine",
           "graafm\\<selection>u0061</selection>chine",
           "graafm<selection>\\u0061</selection>chine",
           "<selection>graafm\\u0061chine</selection>");
  }
###END###
  public void testSelectNamedCharacter() {
    doTest("graafm\\N{LATIN SMALL<caret> LETTER A}chine",
           "graafm\\N{LATIN <selection>SMALL</selection> LETTER A}chine",
           "graafm\\N{<selection>LATIN SMALL LETTER A</selection>}chine",
           "graafm<selection>\\N{LATIN SMALL LETTER A}</selection>chine",
           "<selection>graafm\\N{LATIN SMALL LETTER A}chine</selection>");
  }
###END###
  public void doTest(@NotNull final String before, final String... afters) {
    assert afters != null && afters.length > 0;
    myFixture.configureByText("test.regexp", before);

    final SelectWordHandler action = new SelectWordHandler(null);
    final DataContext dataContext = DataManager.getInstance().getDataContext(myFixture.getEditor().getComponent());
    final Editor editor = myFixture.getEditor();
    for (String after : afters) {
      action.execute(editor, editor.getCaretModel().getCurrentCaret(), dataContext);
      myFixture.checkResult(after);
    }
  }
###END###
    private static String getInputDataFileName(String testName) {
        return Character.toUpperCase(testName.charAt(0)) + testName.substring(1) + ".regexp";
    }
###END###
    private static String getExpectedResultFileName(String testName) {
        return Character.toUpperCase(testName.charAt(0)) + testName.substring(1) + "Expected" + ".regexp";
    }
###END###
    public void testNamedCharacter() {
      myFixture.configureByText(RegExpFileType.INSTANCE, "\\N{SMILE<caret>}");
      final LookupElement[] elements = myFixture.completeBasic();
      final List<String> completion = ContainerUtil.map(elements, LookupElement::getLookupString);
      List<String> alwaysPresent = Arrays.asList(
        "SMILE", "SMILING FACE WITH SMILING EYES", "SMILING FACE WITH HEART-SHAPED EYES",
        "SMILING CAT FACE WITH HEART-SHAPED EYES", "SMILING FACE WITH OPEN MOUTH AND SMILING EYES",
        "SMILING FACE WITH OPEN MOUTH AND TIGHTLY-CLOSED EYES", "CAT FACE WITH WRY SMILE",
        "GRINNING CAT FACE WITH SMILING EYES", "GRINNING FACE WITH SMILING EYES",
        "KISSING FACE WITH SMILING EYES",
        // Unicode 10.0 - Java SE 11
        "SMILING FACE WITH SMILING EYES AND HAND COVERING MOUTH",
        "SIGNWRITING MOUTH SMILE", "SIGNWRITING MOUTH SMILE OPEN",
        "SIGNWRITING MOUTH SMILE WRINKLED",
        // Unicode 11.0 - Java SE 12
        "SMILING FACE WITH SMILING EYES AND THREE HEARTS",
        // Unicode 13.0 - Java SE 15
        "CHORASMIAN LETTER ALEPH", "CHORASMIAN LETTER AYIN", "CHORASMIAN LETTER BETH",
        "CHORASMIAN LETTER CURLED WAW", "CHORASMIAN LETTER DALETH", "CHORASMIAN LETTER GIMEL",
        "CHORASMIAN LETTER HE", "CHORASMIAN LETTER HETH", "CHORASMIAN LETTER KAPH",
        "CHORASMIAN LETTER LAMEDH", "CHORASMIAN LETTER MEM", "CHORASMIAN LETTER NUN",
        "CHORASMIAN LETTER PE", "CHORASMIAN LETTER RESH", "CHORASMIAN LETTER SAMEKH",
        "CHORASMIAN LETTER SHIN", "CHORASMIAN LETTER SMALL ALEPH", "CHORASMIAN LETTER TAW",
        "CHORASMIAN LETTER WAW", "CHORASMIAN LETTER YODH", "CHORASMIAN LETTER ZAYIN");
      assertTrue(completion.toString(), completion.containsAll(alwaysPresent));
      List<String> other = new ArrayList<>(completion);
      other.removeAll(alwaysPresent);
      List<String> maybePresent = Arrays.asList(
        // Unicode 15.0 - Java SE 20
        "LATIN SMALL LETTER D WITH MID-HEIGHT LEFT HOOK", "LATIN SMALL LETTER L WITH MID-HEIGHT LEFT HOOK",
        "LATIN SMALL LETTER N WITH MID-HEIGHT LEFT HOOK", "LATIN SMALL LETTER R WITH MID-HEIGHT LEFT HOOK",
        "LATIN SMALL LETTER S WITH MID-HEIGHT LEFT HOOK", "LATIN SMALL LETTER T WITH MID-HEIGHT LEFT HOOK");
      assertTrue(other.toString(), maybePresent.containsAll(other));
    }
###END###
    public void testBackSlashVariants() {
        List<String> nameList =
          new ArrayList<>(Arrays.asList("d", "D", "s", "S", "w", "W", "b", "B", "A", "G", "Z", "z", "Q", "E",
                                        "t", "n", "r", "f", "a", "e", "h", "H", "v", "V", "R", "X", "b{g}"));
        for (String[] stringArray : DefaultRegExpPropertiesProvider.getInstance().getAllKnownProperties()) {
            nameList.add("p{" + stringArray[0] + "}");
        }
      myFixture.testCompletionVariants(getInputDataFileName(getTestName(true)), ArrayUtilRt.toStringArray(nameList));
    }
###END###
    public void testPropertyVariants() {
        List<String> nameList = new ArrayList<>();
        for (String[] stringArray : DefaultRegExpPropertiesProvider.getInstance().getAllKnownProperties()) {
            nameList.add("{" + stringArray[0] + "}");
        }
      myFixture.testCompletionVariants(getInputDataFileName(getTestName(true)), ArrayUtilRt.toStringArray(nameList));
    }
###END###
    public void testPropertyAlpha() {
      myFixture.configureByText(RegExpFileType.INSTANCE, "\\P{Alp<caret>}");
      myFixture.completeBasic();
      myFixture.checkResult("\\P{Alpha<caret>}");
    }
###END###
    public void doTest() {
        String inputDataFileName = getInputDataFileName(getTestName(true));
        String expectedResultFileName = getExpectedResultFileName(getTestName(true));
        myFixture.testCompletion(inputDataFileName, expectedResultFileName);
    }
###END###
    protected String getBasePath() {
      String homePath = PathManager.getHomePath();
      File candidate = new File(homePath, "community/RegExpSupport/testData/completion");
      if (candidate.isDirectory()) {
        return "/community/RegExpSupport/testData/completion";
      }
      return "/RegExpSupport/testData/completion";
    }
###END###
  protected void setUp() throws Exception {
    super.setUp();
    project.registerService(SmartPointerManager.class, new MockSmartPointerManager());
  }
###END###
  protected String getTestDataPath() {
    return PathManagerEx.getCommunityHomePath() + "/RegExpSupport/testData";
  }
###END###
  public void testSimple1() throws IOException { doCodeTest("|"); }
###END###
  public void testSimple2() throws IOException { doCodeTest("(|\\$.*)\\.class"); }
###END###
  public void testSimple3() throws IOException { doCodeTest("abc"); }
###END###
  public void testSimple4() throws IOException { doCodeTest("multiple words of text"); }
###END###
  public void testSimple5() throws IOException { doCodeTest("ab|cd"); }
###END###
  public void testSimple6() throws IOException { doCodeTest("a*"); }
###END###
  public void testSimple7() throws IOException { doCodeTest("ab*c"); }
###END###
  public void testSimple8() throws IOException { doCodeTest("ab*bc"); }
###END###
  public void testSimple9() throws IOException { doCodeTest("ab+bc"); }
###END###
  public void testSimple10() throws IOException { doCodeTest("ab?bc"); }
###END###
  public void testSimple11() throws IOException { doCodeTest("ab?c"); }
###END###
  public void testSimple12() throws IOException { doCodeTest("a.c"); }
###END###
  public void testSimple13() throws IOException { doCodeTest("a.*c"); }
###END###
  public void testSimple14() throws IOException { doCodeTest("*a"); }
###END###
  public void testSimple15() throws IOException { doCodeTest("a{1}"); }
###END###
  public void testSimple16() throws IOException { doCodeTest("a{}"); }
###END###
  public void testSimple17() throws IOException { doCodeTest("a{"); }
  public void testSimple18() throws IOException { doCodeTest("a}"); }
###END###
  public void testSimple18() throws IOException { doCodeTest("a}
###END###
  public void testSimple19() throws IOException { doCodeTest("a{1,}"); }
###END###
  public void testSimple20() throws IOException { doCodeTest("a{1,2}"); }
###END###
  public void testSimple21() throws IOException { doCodeTest("a{1,foo}"); }
###END###
  public void testSimple22() throws IOException { doCodeTest("\\;"); }
###END###
  public void testSimple23() throws IOException { doCodeTest(""); }
###END###
  public void testQuantifiers1() throws IOException { doCodeTest("a?"); }
###END###
  public void testQuantifiers2() throws IOException { doCodeTest("a+"); }
###END###
  public void testQuantifiers3() throws IOException { doCodeTest("a*"); }
###END###
  public void testQuantifiers4() throws IOException { doCodeTest("a??"); }
###END###
  public void testQuantifiers5() throws IOException { doCodeTest("a+?"); }
###END###
  public void testQuantifiers6() throws IOException { doCodeTest("a*?"); }
###END###
  public void testQuantifiers7() throws IOException { doCodeTest("a?+"); }
###END###
  public void testQuantifiers8() throws IOException { doCodeTest("a++"); }
###END###
  public void testQuantifiers9() throws IOException { doCodeTest("a*+"); }
###END###
  public void testQuantifiers10() throws IOException { doCodeTest("a**"); }
###END###
  public void testQuantifiers11() throws IOException { doCodeTest("a{2}"); }
###END###
  public void testQuantifiers12() throws IOException { doCodeTest("a{1,2}"); }
###END###
  public void testQuantifiers13() throws IOException { doCodeTest("a{2,1}"); }
###END###
  public void testQuantifiers14() throws IOException { doCodeTest("a{0,1}"); }
###END###
  public void testQuantifiers15() throws IOException { doCodeTest("a{1,}"); }
###END###
  public void testQuantifiers16() throws IOException { doCodeTest("a{0,}"); }
###END###
  public void testQuantifiers17() throws IOException { doCodeTest("a{1}"); }
###END###
  public void testQuantifiers18() throws IOException { doCodeTest("a{3,3}"); }
###END###
  public void testQuantifiers19() throws IOException { doCodeTest("a{"); }
  public void testQuantifiers20() throws IOException { doCodeTest("a}"); }
###END###
  public void testQuantifiers20() throws IOException { doCodeTest("a}
###END###
  public void testQuantifiers21() throws IOException { doCodeTest("a{}"); }
###END###
  public void testQuantifiers22() throws IOException { doCodeTest("{1,2}"); }
###END###
  public void testCharclasses1() throws IOException { doCodeTest("a[bc]d"); }
###END###
  public void testCharclasses2() throws IOException { doCodeTest("a[b-d]e"); }
###END###
  public void testCharclasses3() throws IOException { doCodeTest("a[b-d]"); }
###END###
  public void testCharclasses4() throws IOException { doCodeTest("a[b-a]"); }
###END###
  public void testCharclasses5() throws IOException { doCodeTest("a[-b]"); }
###END###
  public void testCharclasses6() throws IOException { doCodeTest("a[b-]"); }
###END###
  public void testCharclasses7() throws IOException { doCodeTest("[a-[b]]"); }
###END###
  public void testCharclasses8() throws IOException { doCodeTest("a[b&&[cd]]"); }
###END###
  public void testCharclasses9() throws IOException { doCodeTest("a[b-&&[cd]]"); }
###END###
  public void testCharclasses10() throws IOException { doCodeTest("a[b&&-]"); }
###END###
  public void testCharclasses11() throws IOException { doCodeTest("a[b&&-b]"); }
###END###
  public void testCharclasses12() throws IOException { doCodeTest("[&&]"); }
###END###
  public void testCharclasses13() throws IOException { doCodeTest("[&&[^\\d]]"); }
###END###
  public void testCharclasses14() throws IOException { doCodeTest("[a&&]"); }
###END###
  public void testCharclasses15() throws IOException { doCodeTest("a[b&&c&&d]"); }
###END###
  public void testCharclasses16() throws IOException { doCodeTest("a[b&&c&&d-e&&f]"); }
###END###
  public void testCharclasses17() throws IOException { doCodeTest("[a&&]"); }
###END###
  public void testCharclasses18() throws IOException { doCodeTest("a[a[b][c]]"); }
###END###
  public void testCharclasses19() throws IOException { doCodeTest("[a-[]]"); }
###END###
  public void testCharclasses20() throws IOException { doCodeTest("[a-[b"); }
###END###
  public void testCharclasses21() throws IOException { doCodeTest("[a[^b]]"); }
###END###
  public void testCharclasses22() throws IOException { doCodeTest("a[a[b[c]][d]]"); }
###END###
  public void testCharclasses23() throws IOException { doCodeTest("a[\\t--]"); }
###END###
  public void testCharclasses24() throws IOException { doCodeTest("a[\\t--]"); }
###END###
  public void testCharclasses25() throws IOException { doCodeTest("a[\\t---]"); }
###END###
  public void testCharclasses26() throws IOException { doCodeTest("a[-]?c"); }
###END###
  public void testCharclasses27() throws IOException { doCodeTest("a["); }
###END###
  public void testCharclasses28() throws IOException { doCodeTest("a]"); }
###END###
  public void testCharclasses29() throws IOException { doCodeTest("[a-["); }
###END###
  public void testCharclasses30() throws IOException { doCodeTest("a[]]"); }
###END###
  public void testCharclasses31() throws IOException { doCodeTest("a[^bc]d"); }
###END###
  public void testCharclasses32() throws IOException { doCodeTest("a[^bc]"); }
###END###
  public void testCharclasses33() throws IOException { doCodeTest("a[]b"); }
###END###
  public void testCharclasses34() throws IOException { doCodeTest("[^]"); }
###END###
  public void testCharclasses35() throws IOException { doCodeTest("[abhgefdc]ij"); }
###END###
  public void testCharclasses36() throws IOException { doCodeTest("[a-zA-Z_][a-zA-Z0-9_]*"); }
###END###
  public void testCharclasses37() throws IOException { doCodeTest("([a-c]+?)c"); }
###END###
  public void testCharclasses38() throws IOException { doCodeTest("([ab]*?)b"); }
###END###
  public void testCharclasses39() throws IOException { doCodeTest("([ab]*)b"); }
###END###
  public void testCharclasses40() throws IOException { doCodeTest("([ab]??)b"); }
###END###
  public void testCharclasses41() throws IOException { doCodeTest("(c[ab]?)b"); }
###END###
  public void testCharclasses42() throws IOException { doCodeTest("(c[ab]??)b"); }
###END###
  public void testCharclasses43() throws IOException { doCodeTest("(c[ab]*?)b"); }
###END###
  public void testCharclasses44() throws IOException { doCodeTest("a[bcd]+dcdcde"); }
###END###
  public void testCharclasses45() throws IOException { doCodeTest("[k]"); }
###END###
  public void testCharclasses46() throws IOException { doCodeTest("a[bcd]*dcdcde"); }
###END###
  public void testCharclasses47() throws IOException { doCodeTest("[^ab]*"); }
###END###
  public void testCharclasses48() throws IOException { doCodeTest("a[.]b"); }
###END###
  public void testCharclasses49() throws IOException { doCodeTest("a[+*?]b"); }
###END###
  public void testCharclasses50() throws IOException { doCodeTest("a[\\p{IsDigit}\\p{IsAlpha}]b"); }
###END###
  public void testCharclasses51() throws IOException { doCodeTest("[\\p{L}&&[^\\p{Lu}]]"); }
###END###
  public void testCharclasses52() throws IOException { doCodeTest("\\pL\\pM\\pZ\\pS\\pN\\pP\\pC\\PL\\PM\\PZ\\PS\\PN\\PP\\PC"); }
###END###
  public void testCharclasses53() throws IOException { doCodeTest("\\pA"); }
###END###
  public void testCharclasses54() throws IOException { doCodeTest("\\pl"); }
###END###
  public void testCharclasses55() throws IOException { doCodeTest("a\\p"); }
###END###
  public void testCharclasses56() throws IOException { doCodeTest("a\\p{}"); }
###END###
  public void testCharclasses57() throws IOException { doCodeTest("a\\p}
###END###
  public void testCharclasses58() throws IOException { doCodeTest("a\\p{123}"); }
###END###
  public void testCharclasses59() throws IOException { doCodeTest("[\\p{nothing}]"); }
###END###
  public void testCharclasses60() throws IOException { doCodeTest("a\\p{*}b"); }
###END###
  public void testCharclasses61() throws IOException { doCodeTest("[\\w-\\w]"); }
###END###
  public void testCharclasses62() throws IOException { doCodeTest("[a-\\w]"); }
###END###
  public void testCharclasses63() throws IOException { doCodeTest("(?x)abc #foo \\q bar\n# foo\n(?-xi)xyz(?i:ABC)"); }
###END###
  public void testCharclasses64() throws IOException { doCodeTest("[\\ud800\\udc00-\\udbff\\udfff]"); }
###END###
  public void testCharclasses65() throws IOException { doCodeTest("\\R"); }
###END###
  public void testCharclasses66() throws IOException { doCodeTest("\\X"); }
###END###
  public void testCharclasses67() throws IOException { doCodeTest("\\-[\\*\\-\\[\\]\\\\\\+]"); }
###END###
  public void testCharclasses68() throws IOException { doCodeTest("[\\b]"); }
###END###
  public void testCharClasses69() throws IOException { doCodeTest("\\p{^L}"); }
###END###
  public void testCharClasses70() throws IOException { doCodeTest("[&&&&a]"); }
###END###
  public void testCharClasses71() throws IOException { doCodeTest("[a-\\Qz\\E]"); }
###END###
  public void testCharClasses72() throws IOException { doCodeTest("([\\^])"); }
###END###
  public void testCharClasses73() throws IOException { doCodeTest("[i-[:]]*"); }
###END###
  public void testGroups1() throws IOException { doCodeTest("()ef"); }
###END###
  public void testGroups2() throws IOException { doCodeTest("()*"); }
###END###
  public void testGroups3() throws IOException { doCodeTest("()"); }
###END###
  public void testGroups4() throws IOException { doCodeTest("(|)"); }
###END###
  public void testGroups5() throws IOException { doCodeTest("(*)b"); }
###END###
  public void testGroups6() throws IOException { doCodeTest("((a))"); }
###END###
  public void testGroups7() throws IOException { doCodeTest("(a)b(c)"); }
###END###
  public void testGroups8() throws IOException { doCodeTest("(a*)*"); }
###END###
  public void testGroups9() throws IOException { doCodeTest("(a*)+"); }
###END###
  public void testGroups10() throws IOException { doCodeTest("(a|)*"); }
###END###
  public void testGroups11() throws IOException { doCodeTest("(ab|cd)e"); }
###END###
  public void testGroups12() throws IOException { doCodeTest("(.*)c(.*)"); }
###END###
  public void testGroups13() throws IOException { doCodeTest("\\((.*), (.*)\\)"); }
###END###
  public void testGroups14() throws IOException { doCodeTest("a(bc)d"); }
###END###
  public void testGroups15() throws IOException { doCodeTest("([abc])*d"); }
###END###
  public void testGroups16() throws IOException { doCodeTest("((((((((((a)))))))))"); }
###END###
  public void testGroups17() throws IOException { doCodeTest("([abc])*bcd"); }
###END###
  public void testGroups18() throws IOException { doCodeTest("(a|b)c*d"); }
###END###
  public void testGroups19() throws IOException { doCodeTest("a([bc]*)c*"); }
###END###
  public void testGroups20() throws IOException { doCodeTest("((a)(b)c)(d)"); }
###END###
  public void testGroups21() throws IOException { doCodeTest("(ab|a)b*c"); }
###END###
  public void testGroups22() throws IOException { doCodeTest("(ab|ab*)bc"); }
###END###
  public void testGroups23() throws IOException { doCodeTest("(a|b|c|d|e)f"); }
###END###
  public void testGroups24() throws IOException { doCodeTest("a([bc]*)(c*d)"); }
###END###
  public void testGroups25() throws IOException { doCodeTest("a([bc]+)(c*d)"); }
###END###
  public void testGroups26() throws IOException { doCodeTest("a([bc]*)(c+d)"); }
###END###
  public void testGroups27() throws IOException { doCodeTest("(a+|b)*"); }
###END###
  public void testGroups28() throws IOException { doCodeTest("(a+|b)+"); }
###END###
  public void testGroups29() throws IOException { doCodeTest("(a+|b)?"); }
###END###
  public void testGroups30() throws IOException { doCodeTest("(^*"); }
###END###
  public void testGroups31() throws IOException { doCodeTest(")("); }
###END###
  public void testGroups32() throws IOException { doCodeTest("(?i:*)"); }
###END###
  public void testGroups33() throws IOException { doCodeTest("(?<asdf>[a-c])\\1"); }
###END###
  public void testGroups34() throws IOException { doCodeTest("(?<asdf>[a-c])\\k<asdf>"); }
###END###
  public void testGroups35() throws IOException { doCodeTest("\\k<adsf>"); }
###END###
  public void testGroups37() throws IOException { doCodeTest("(?P=name)"); }
###END###
  public void testGroups38() throws IOException { doCodeTest("\\g'name'"); }
###END###
  public void testGroups39() throws IOException { doCodeTest("(?(name)yes-pattern|no-pattern)"); }
###END###
  public void testGroups41() throws IOException { doCodeTest("(?>atomic)"); }
###END###
  public void testGroups42() throws IOException { doCodeTest("(?:non-capturing)"); }
###END###
  public void testGroups43() throws IOException { doCodeTest("(?(name)yes-pattern|no_pattern|maybe-pattern)"); }
###END###
  public void testEscapes1() throws IOException { doCodeTest("\\q"); }
###END###
  public void testEscapes2() throws IOException { doCodeTest("\\#"); }
###END###
  public void testEscapes3() throws IOException { doCodeTest("a\\"); }
###END###
  public void testEscapes4() throws IOException { doCodeTest("a\\(b"); }
###END###
  public void testEscapes5() throws IOException { doCodeTest("a\\(*b"); }
###END###
  public void testEscapes6() throws IOException { doCodeTest("a\\\\b"); }
###END###
  public void testEscapes7() throws IOException { doCodeTest("\\u004a"); }
###END###
  public void testEscapes8() throws IOException { doCodeTest("\\0123"); }
###END###
  public void testEscapes9() throws IOException { doCodeTest("\\0"); }
###END###
  public void testEscapes10() throws IOException { doCodeTest("\\x4a"); }
###END###
  public void testEscapes11() throws IOException { doCodeTest("\\x{0}"); }
###END###
  public void testEscapes12() throws IOException { doCodeTest("\\x{2011F}"); }
###END###
  public void testEscapes13() throws IOException { doCodeTest("[\\x4a-\\x4b]"); }
###END###
  public void testEscapes14() throws IOException { doCodeTest("[a-a]"); }
###END###
  public void testEscapes15() throws IOException { doCodeTest("[\\x4a-\\x3f]"); }
###END###
  public void testEscapes16() throws IOException { doCodeTest("[\\udbff\\udfff-\\ud800\\udc00]"); }
###END###
  public void testEscapes17() throws IOException { doCodeTest("[\\ud800\\udc00-\\udbff\\udfff]"); }
###END###
  public void testEscapes18() throws IOException { doCodeTest("[z-a]"); }
###END###
  public void testEscapes19() throws IOException { doCodeTest("[a-z]"); }
###END###
  public void testEscapes20() throws IOException { doCodeTest("a\\Qabc?*+.))]][]\\Eb"); }
###END###
  public void testEscapes21() throws IOException { doCodeTest("(a\\Qabc?*+.))]][]\\Eb)"); }
###END###
  public void testEscapes22() throws IOException { doCodeTest("[\\Qabc?*+.))]][]\\E]"); }
###END###
  public void testEscapes23() throws IOException { doCodeTest("a\\Qabc?*+.))]][]\\E)"); }
###END###
  public void testEscapes24() throws IOException { doCodeTest("\\Q\\j\\E"); }
###END###
  public void testEscapes25() throws IOException { doCodeTest("\\c0"); }
###END###
  public void testEscapes26() throws IOException { doCodeTest("[\\]]"); }
###END###
  public void testEscapes27() throws IOException { doCodeTest("[^\\]]"); }
###END###
  public void testEscapes28() throws IOException { doCodeTest("[a\\]]"); }
###END###
  public void testEscapes29() throws IOException { doCodeTest("[^a\\]]"); }
###END###
  public void testEscapes30() throws IOException { doCodeTest("\\[\\]$"); }
###END###
  public void testEscapes31() throws IOException { doCodeTest("\\ud800"); }
###END###
  public void testAnchors1() throws IOException { doCodeTest("^*"); }
###END###
  public void testAnchors2() throws IOException { doCodeTest("$*"); }
###END###
  public void testAnchors3() throws IOException { doCodeTest("^abc"); }
###END###
  public void testAnchors4() throws IOException { doCodeTest("^abc$"); }
###END###
  public void testAnchors5() throws IOException { doCodeTest("abc$"); }
###END###
  public void testAnchors6() throws IOException { doCodeTest("^"); }
###END###
  public void testAnchors7() throws IOException { doCodeTest("$"); }
###END###
  public void testAnchors8() throws IOException { doCodeTest("$b"); }
###END###
  public void testAnchors9() throws IOException { doCodeTest("^(ab|cd)e"); }
###END###
  public void testAnchors10() throws IOException { doCodeTest("^a(bc+|b[eh])g|.h$"); }
###END###
  public void testNamedchars1() throws IOException { doCodeTest("a*b\\s+c"); }
###END###
  public void testNamedchars2() throws IOException { doCodeTest("\\d+"); }
###END###
  public void testNamedchars3() throws IOException { doCodeTest("^\\p{javaJavaIdentifierStart}+\\p{javaJavaIdentifierPart}+$"); }
###END###
  public void testNamedchars4() throws IOException { doCodeTest("\\p{IsDigit}\\p{IsAlpha}"); }
###END###
  public void testNamedchars5() throws IOException { doCodeTest("\\p{InLATIN_1_SUPPLEMENT}"); }
###END###
  public void testNamedchars6() throws IOException { doCodeTest("[a-e]?d\\\\e"); }
###END###
  public void testNamedchars7() throws IOException { doCodeTest("((\\w+)/)*(\\w+)"); }
###END###
  public void testNamedchars8() throws IOException { doCodeTest("\\p{Digit}+"); }
###END###
  public void testNamedchars9() throws IOException { doCodeTest("[:xdigit:]+"); }
###END###
  public void testNamedchars10() throws IOException { doCodeTest("\\p{unknown}+"); }
###END###
  public void testNamedchars11() throws IOException { doCodeTest("[:^xdigit:]+"); }
###END###
  public void testNamedchars12() throws IOException { doCodeTest("\\p{InArabic Extended-A}"); }
###END###
  public void testNamedchars13() throws IOException { doCodeTest("\\N{Mahjong Tile Winter}"); }
###END###
  public void testNamedchars14() throws IOException { doCodeTest("[\\N{Mahjong Tile Winter}]"); }
###END###
  public void testNamedchars15() throws IOException { doCodeTest("[\\N{LATIN SMALL LETTER A}-\\N{LATIN SMALL LETTER Z}]"); }
###END###
  public void testBackrefs1() throws IOException { doCodeTest("(ac*)c*d[ac]*\\1"); }
###END###
  public void testBackrefs2() throws IOException { doCodeTest("(.)=\\1"); }
###END###
  public void testBackrefs3() throws IOException { doCodeTest("([ab])=\\1"); }
###END###
  public void testBackrefs4() throws IOException { doCodeTest("([ab]+)=\\1"); }
###END###
  public void testBackrefs5() throws IOException { doCodeTest("(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)\\105"); }
###END###
  public void testBackrefs6() throws IOException { doCodeTest("(.)\\11"); }
###END###
  public void testBackrefs7() throws IOException { doCodeTest("([ab]+)=\\2"); }
###END###
  public void testBackrefs8() throws IOException { doCodeTest("([ab]+)=\\3"); }
###END###
  public void testBackrefs9() throws IOException { doCodeTest("([ab]+=\\1)"); }
###END###
  public void testComplex1() throws IOException { doCodeTest("z(\\w\\s+(?:\\w\\s+\\w)+)z"); }
###END###
  public void testComplex2() throws IOException { doCodeTest("(([hH][tT]{2}[pP]|[fF][tT][pP]):\\/\\/)?[a-zA-Z0-9\\-]+(\\.[a-zA-Z0-9\\-]+)*"); }
###END###
  public void testComplex3() throws IOException { doCodeTest("((?:[hH][tT]{2}[pP]|[fF][tT][pP]):\\/\\/)?[a-zA-Z0-9\\-]+(\\.[a-zA-Z0-9\\-]+)*"); }
###END###
  public void testComplex4() throws IOException { doCodeTest("(([hH][tT]{2}[pP]|[fF][tT][pP]):\\/\\/)?[a-zA-Z0-9\\-]+(?:\\.[a-zA-Z0-9\\-]+)*"); }
###END###
  public void testComplex5() throws IOException { doCodeTest("(?:([hH][tT]{2}[pP]|[fF][tT][pP]):\\/\\/)?[a-zA-Z0-9\\-]+(\\.[a-zA-Z0-9\\-]+)*"); }
###END###
  public void testComplex6() throws IOException { doCodeTest("^(?:([hH][tT]{2}[pP]|[fF][tT][pP]):\\/\\/)?[a-zA-Z0-9\\-]+(\\.[a-zA-Z0-9\\-]+)*$"); }
###END###
  public void testComplex7() throws IOException { doCodeTest("^(?:(?:[hH][tT]{2}[pP]|[fF][tT][pP]):\\/\\/)?[a-zA-Z0-9\\-]+(?:\\.[a-zA-Z0-9\\-]+)*$"); }
###END###
  public void testIncomplete1() throws IOException { doCodeTest("abc\\"); }
###END###
  public void testIncomplete2() throws IOException { doCodeTest("abc[\\"); }
###END###
  public void testIncomplete3() throws IOException { doCodeTest("abc\\x"); }
###END###
  public void testIncomplete4() throws IOException { doCodeTest("abc\\x1"); }
###END###
  public void testIncomplete6() throws IOException { doCodeTest("abc\\x{}"); }
###END###
  public void testIncomplete7() throws IOException { doCodeTest("abc\\x{0"); }
  public void testIncomplete8() throws IOException { doCodeTest("abc\\u"); }
  public void testIncomplete9() throws IOException { doCodeTest("abc\\u22"); }
  public void testIncomplete10() throws IOException { doCodeTest("\\Qabc"); }
  public void testIncomplete11() throws IOException { doCodeTest("\\Q"); }
  public void testIncomplete12() throws IOException { doCodeTest("\\E"); }
  public void testIncomplete13() throws IOException { doCodeTest("a|*"); }

  public void testRegressions1() throws IOException { doCodeTest("("); }
  public void testRegressions2() throws IOException { doCodeTest("[^^]"); }
  public void testRegressions3() throws IOException { doCodeTest("a)b"); }
  public void testRegressions4() throws IOException { doCodeTest("\\s*@return(?:s)?\\s*(?:(?:\\{|:)?\\s*(?([^\\s\\}]+)\\s*\\}?\\s*)?(.*)"); }
###END###
  public void testIncomplete8() throws IOException { doCodeTest("abc\\u"); }
###END###
  public void testIncomplete9() throws IOException { doCodeTest("abc\\u22"); }
###END###
  public void testIncomplete10() throws IOException { doCodeTest("\\Qabc"); }
###END###
  public void testIncomplete11() throws IOException { doCodeTest("\\Q"); }
###END###
  public void testIncomplete12() throws IOException { doCodeTest("\\E"); }
###END###
  public void testIncomplete13() throws IOException { doCodeTest("a|*"); }
###END###
  public void testRegressions1() throws IOException { doCodeTest("("); }
###END###
  public void testRegressions2() throws IOException { doCodeTest("[^^]"); }
###END###
  public void testRegressions3() throws IOException { doCodeTest("a)b"); }
###END###
  public void testRegressions4() throws IOException { doCodeTest("\\s*@return(?:s)?\\s*(?:(?:\\{|:)?\\s*(?([^\\s\\}]+)\\s*\\}
###END###
  public void testOptions1() throws IOException { doCodeTest("(?iZm)abc"); }
###END###
  public void testOptions2() throws IOException { doCodeTest("(?idmsuxU)nice"); }
###END###
  public void testOptions3() throws IOException { doCodeTest("(?idm-suxU)one(?suxU-idm)two"); }
###END###
  public void testOptions4() throws IOException { doCodeTest("(?i|abc"); }
###END###
  public void testTests1() throws IOException { doCodeTest("abc)"); }
###END###
  public void testTests2() throws IOException { doCodeTest("(abc"); }
###END###
  public void testTests3() throws IOException { doCodeTest("a+b+c"); }
###END###
  public void testTests4() throws IOException { doCodeTest("a**"); }
###END###
  public void testTests5() throws IOException { doCodeTest("a++"); }
###END###
  public void testTests6() throws IOException { doCodeTest("ab*"); }
###END###
  public void testTests7() throws IOException { doCodeTest("abcd*efg"); }
###END###
  public void testTests8() throws IOException { doCodeTest("a|b|c|d|e"); }
###END###
  public void testTests9() throws IOException { doCodeTest("(bc+d$|ef*g.|h?i(j|k))"); }
###END###
  public void testTests10() throws IOException { doCodeTest("a*(b*c*)"); }
###END###
  public void testTests11() throws IOException { doCodeTest("a?b+c*"); }
###END###
  public void testTests12() throws IOException { doCodeTest("i am a green (giant|man|martian)"); }
###END###
  public void testTests13() throws IOException { doCodeTest("(wee|week)(knights|knight)"); }
###END###
  public void testTests14() throws IOException { doCodeTest("(a.*b)(a.*b)"); }
###END###
  public void testTests15() throws IOException { doCodeTest("(\\s*\\w+)?"); }
###END###
  public void testTests16() throws IOException { doCodeTest("(?:a)"); }
###END###
  public void testTests17() throws IOException { doCodeTest("(?:\\w)"); }
###END###
  public void testTests18() throws IOException { doCodeTest("(?:\\w\\s\\w)+"); }
###END###
  public void testTests19() throws IOException { doCodeTest("(a\\w)(?:,(a\\w))+"); }
###END###
  public void testTests20() throws IOException { doCodeTest("abc.*?x+yz"); }
###END###
  public void testTests21() throws IOException { doCodeTest("abc.+?x+yz"); }
###END###
  public void testTests22() throws IOException { doCodeTest("a.+?(c|d)"); }
###END###
  public void testTests23() throws IOException { doCodeTest("a.+(c|d)"); }
###END###
  public void testTests24() throws IOException { doCodeTest("a+?b+?c+?"); }
###END###
  public void testRealLife1() throws IOException { doCodeTest("x:found=\"(true|false)\""); }
###END###
  public void testRealLife2() throws IOException { doCodeTest("(?:\\s)|(?:/\\*.*\\*/)|(?://[^\\n]*)"); }
###END###
  public void testRealLife3() throws IOException { doCodeTest("((?:\\p{Alpha}\\:)?[0-9 a-z_A-Z\\-\\\\./]+)"); }
###END###
  public void testRealLife4() throws IOException { doCodeTest("^[\\w\\+\\.\\-]{2,}:"); }
###END###
  public void testRealLife5() throws IOException { doCodeTest("#(.*)$"); }
###END###
  public void testRealLife6() throws IOException { doCodeTest("^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)"); }
###END###
  public void testRealLife7() throws IOException { doCodeTest("(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)"); }
###END###
  public void testRealLife8() throws IOException { doCodeTest("usd [+-]?[0-9]+.[0-9][0-9]"); }
###END###
  public void testRealLife9() throws IOException { doCodeTest("\\b(\\w+)(\\s+\\1)+\\b"); }
###END###
  public void testRealLife10() throws IOException { doCodeTest(".*?(<(error|warning|info)(?: descr=\"((?:[^\"\\\\]|\\\\\")*)\")?(?: type=\"([0-9A-Z_]+)\")?(?: foreground=\"([0-9xa-f]+)\")?(?: background=\"([0-9xa-f]+)\")?(?: effectcolor=\"([0-9xa-f]+)\")?(?: effecttype=\"([A-Z]+)\")?(?: fonttype=\"([0-9]+)\")?(/)?>)(.*)"); }
###END###
  public void testBug1() throws IOException { doCodeTest("[{][\\w\\.]*[}]"); }
###END###
  public void testBug2() throws IOException { doCodeTest("[a-z0-9!\\#$%&'*+/=?^_`{|}~-]+"); }
###END###
  public void testBug5() throws IOException { doCodeTest("\\{"); }
  public void testBug6() throws IOException { doCodeTest("(<=\\s)-{3,}(?>\\s)"); }
  public void testBug7() throws IOException { doCodeTest("(?x)a\\ b\\ c"); }
  public void testBug8() throws IOException { doCodeTest("a\\ b"); }
  public void testBug9() throws IOException { doCodeTest("(^|\\.)\\*(?=(\\.|$))"); }
  public void testBug10() throws IOException { doCodeTest("\\h \\H \\v \\V"); }

  public void testParse1() throws IOException { doCodeTest("123 | 456"); }
  public void testParse2() throws IOException { doCodeTest("1**"); }
  public void testParse3() throws IOException { doCodeTest("(([hH][tT]{2}[pP]|[fF][tT][pP])://)?[a-zA-Z0-9\\-]+(\\.[a-zA-Z0-9\\-]+)*"); }

  public void testCategoryShorthand1() throws IOException { doCodeTest("\\pL"); }

  public void testCapabilitiesProvider() throws IOException {
    RegExpCapabilitiesProvider provider = (host, def) -> EnumSet.of(POSIX_BRACKET_EXPRESSIONS);
    try {
      RegExpCapabilitiesProvider.EP.addExplicitExtension(RegExpLanguage.INSTANCE, provider);
      PsiFile file = createPsiFile("c", "(?#xxx)");
      PsiComment context = SyntaxTraverser.psiTraverser(file).filter(PsiComment.class).first();
      myFile = createPsiFile("a", "[[:blank:]]");
      SmartPsiElementPointer<PsiComment> pointer = SmartPointerManager.getInstance(getProject()).createSmartPsiElementPointer(context, file);
      myFile.putUserData(FileContextUtil.INJECTED_IN_ELEMENT, pointer);
      ensureParsed(myFile);
      checkResult(myFilePrefix + getTestName(), myFile);
    }
    finally {
      RegExpCapabilitiesProvider.EP.removeExplicitExtension(RegExpLanguage.INSTANCE, provider);
    }
  }
}
###END###
  public void testBug6() throws IOException { doCodeTest("(<=\\s)-{3,}(?>\\s)"); }
###END###
  public void testBug7() throws IOException { doCodeTest("(?x)a\\ b\\ c"); }
###END###
  public void testBug8() throws IOException { doCodeTest("a\\ b"); }
###END###
  public void testBug9() throws IOException { doCodeTest("(^|\\.)\\*(?=(\\.|$))"); }
###END###
  public void testBug10() throws IOException { doCodeTest("\\h \\H \\v \\V"); }
###END###
  public void testParse1() throws IOException { doCodeTest("123 | 456"); }
###END###
  public void testParse2() throws IOException { doCodeTest("1**"); }
###END###
  public void testParse3() throws IOException { doCodeTest("(([hH][tT]{2}[pP]|[fF][tT][pP])://)?[a-zA-Z0-9\\-]+(\\.[a-zA-Z0-9\\-]+)*"); }
###END###
  public void testCategoryShorthand1() throws IOException { doCodeTest("\\pL"); }
###END###
  public void testCapabilitiesProvider() throws IOException {
    RegExpCapabilitiesProvider provider = (host, def) -> EnumSet.of(POSIX_BRACKET_EXPRESSIONS);
    try {
      RegExpCapabilitiesProvider.EP.addExplicitExtension(RegExpLanguage.INSTANCE, provider);
      PsiFile file = createPsiFile("c", "(?#xxx)");
      PsiComment context = SyntaxTraverser.psiTraverser(file).filter(PsiComment.class).first();
      myFile = createPsiFile("a", "[[:blank:]]");
      SmartPsiElementPointer<PsiComment> pointer = SmartPointerManager.getInstance(getProject()).createSmartPsiElementPointer(context, file);
      myFile.putUserData(FileContextUtil.INJECTED_IN_ELEMENT, pointer);
      ensureParsed(myFile);
      checkResult(myFilePrefix + getTestName(), myFile);
    }
    finally {
      RegExpCapabilitiesProvider.EP.removeExplicitExtension(RegExpLanguage.INSTANCE, provider);
    }
  }
###END###
  public void testNestedQuantifiers1() {
    highlightTest("<warning descr=\"Potential exponential backtracking\">(.*a){10}</warning>");
  }
###END###
  public void testNestedQuantifiers2() {
    highlightTest("<warning descr=\"Potential exponential backtracking\">(a+)+</warning>");
  }
###END###
  public void testPossessiveQuantifier() {
    highlightTest("(a+)++");
  }
###END###
  public void testAtomicGroup() {
    highlightTest("(?>a+)+");
  }
###END###
  protected LocalInspectionTool getInspection() {
    return new ReDoSInspection();
  }
###END###
  public void testSimple() {
    highlightTest("<warning descr=\"2 consecutive spaces in RegExp\">  </warning>");
  }
###END###
  public void testIgnoreQuoted() {
    highlightTest("\\Q     \\E");
  }
###END###
  public void testIgnoreInClass() {
    highlightTest("[   ]");
  }
###END###
  public void testIgnoreInClass2() {
    highlightTest(" [ -x]");
  }
###END###
  public void testReplacement() {
    quickfixTest("<warning descr=\"5 consecutive spaces in RegExp\">     </warning>", " {5}", "Replace with ' {5}'");
  }
###END###
  public void testReplacement2() {
    quickfixTest("\\Q     \\E<warning descr=\"3 consecutive spaces in RegExp\">   <caret></warning>", "\\Q     \\E {3}", "Replace with ' {3}'");
  }
###END###
  public void testEscapedWhitespace() {
    quickfixTest("<warning descr=\"3 consecutive spaces in RegExp\"><caret>\\   </warning>", " {3}", "Replace with ' {3}",
                 RegExpFileType.forLanguage(EcmaScriptRegexpLanguage.INSTANCE));
  }
###END###
  public void testNoStringIndexOutOfBoundsException() {
    highlightTest("<error descr=\"Illegal/unsupported escape sequence\">\\</error>");
  }
###END###
  public void testNoStringIndexOutOfBoundsException2() {
    highlightTest("<error descr=\"Illegal/unsupported escape sequence\">\\c</error>");
  }
###END###
  protected LocalInspectionTool getInspection() {
    return new RepeatedSpaceInspection();
  }
###END###
  protected @NotNull LocalInspectionTool getInspection() {
    return new RegExpRedundantClassElementInspection();
  }
###END###
  public void testAnyDigit() {
    quickfixTest("[\\w.<weak_warning descr=\"Redundant '\\d' in RegExp\"><caret>\\d</weak_warning>]",
                 "[\\w.]", RegExpBundle.message("inspection.quick.fix.remove.redundant.0.class.element", "\\d"));
  }
###END###
  public void testAnyNonDigit() {
    quickfixTest("^[\\W.<weak_warning descr=\"Redundant '\\D' in RegExp\"><caret>\\D</weak_warning>]",
                 "^[\\W.]", RegExpBundle.message("inspection.quick.fix.remove.redundant.0.class.element", "\\D"));
  }
###END###
  public void testNoHighlighting() {
    highlightTest("\\w{2}[.,]?[\\d\\W]");
  }
###END###
  public void testSimple() {
    quickfixTest("<warning descr=\"Duplicate branch in alternation\">\\t<caret></warning>|<warning descr=\"Duplicate branch in alternation\">\\x09</warning>", "\\x09", "Remove duplicate branch");
  }
###END###
  public void testMoreBranches() {
    quickfixTest("<warning descr=\"Duplicate branch in alternation\">a{3}</warning>|<warning descr=\"Duplicate branch in alternation\">a<caret>{3,3}</warning>|b|c", "a{3}|b|c", "Remove duplicate branch");
  }
###END###
  public void testOrderIrrelevant() {
    highlightTest("<warning descr=\"Duplicate branch in alternation\">[abc]</warning>|<warning descr=\"Duplicate branch in alternation\">[cba]</warning>");
  }
###END###
  public void testEmptyBranches() {
    highlightTest("|||");
  }
###END###
  public void testNoWarn() {
    highlightTest("([aeiou][^aeiou])*|([^aeiou][aeiou])*");
  }
###END###
  public void testBrokenRange() {
    highlightTest("<warning descr=\"Duplicate branch in alternation\">[a-<error descr=\"Illegal character range\">\\</error>w]</warning>|<warning descr=\"Duplicate branch in alternation\">[a-<error descr=\"Illegal character range\">\\</error>w]</warning>");
  }
###END###
  protected LocalInspectionTool getInspection() {
    return new DuplicateAlternationBranchInspection();
  }
###END###
  public void testRedundantRange() {
    doTest("[ah-hz]", 2, 3, "h", "[ahz]");
  }
###END###
  public void testNegatedDigit() {
    doTest("[^\\d]", "\\D");
  }
###END###
  public void testNegatedDigitRange() {
    highlightTest("[^0-9]"); // no warn; replacing with \D is not equivalent in Unicode context
  }
###END###
  public void testNegatedWordClassCharExpression() {
    highlightTest("[^0-9a-zA-Z_]"); // no warn; replacing with \W is not equivalent in Unicode context
  }
###END###
  public void testDigitRange() {
    highlightTest("[^0-9abc]"); // no warn; replacing with [^\dabc] is not equivalent in Unicode context
  }
###END###
  public void testDigitRange2() {
    highlightTest("[0-9abc]"); // no warn; replacing with \d is not equivalent in Unicode context
  }
###END###
  public void testSingleElementClass() {
    doTest("[a]", "a");
  }
###END###
  public void testNoWarnSingleElementClass() {
    highlightTest("[.]");
  }
###END###
  public void testSimpleDigitRange() {
    highlightTest("[0-9]"); // no warn; replacing with \d is not equivalent in Unicode context
  }
###END###
  public void testWordCharClassExpression() {
    highlightTest("[0-9a-zA-Z_]"); // no warn; replacing with \w is not equivalent in Unicode context
  }
###END###
  public void testProperty() {
    doTest("\\p{IsDigit}", "\\d");
  }
###END###
  public void testStarToPlusNoWarm() {
    highlightTest("bba*c");
  }
###END###
  public void testStarToPlusNoWarn2() {
    highlightTest("b(a)(a)*c");
  }
###END###
  public void testStarToPlus() {
    doTest("baa*c", 1, 3, "a+", "ba+c");
  }
###END###
  public void testSingleRepetition() {
    quickfixTest("a<weak_warning descr=\"'{1}' is redundant\"><caret>{1}</weak_warning>",
                 "a", CommonQuickFixBundle.message("fix.remove", "{1}"));
  }
###END###
  public void testSimplifiableRange1() {
    doTest("a{0,1}", 1, 5, "?", "a?");
  }
###END###
  public void testSimplifiableRange2() {
    doTest("a{1,}", 1, 4, "+", "a+");
  }
###END###
  public void testSimplifiableRange3() {
    doTest("a{0,}", 1, 4, "*", "a*");
  }
###END###
  public void testFixedRepetitionRange() {
    doTest("a{3,3}", 1, 5, "{3}", "a{3}");
  }
###END###
  public void testSinglePosixBracketExpressionInClass() {
    highlightTest("[[:upper:]]", RegExpFileType.forLanguage(EcmaScriptRegexpLanguage.INSTANCE));
  }
###END###
  private void doTest(@Language("RegExp") String code, @Language("RegExp") String replacement) {
    doTest(code, 0, code.length(), replacement, replacement);
  }
###END###
  private void doTest(@Language("RegExp") String code, int offset, int length,
                      String replacement,
                      @Language("RegExp") String result) {
    final String suspect = code.substring(offset, offset + length);
    @Language("RegExp") final String warning =
      code.substring(0, offset) + "<weak_warning descr=\"'" + suspect + "' can be simplified to '" + replacement + "'\"><caret>" +
      suspect + "</weak_warning>" + code.substring(offset + length);
    quickfixTest(warning, result, CommonQuickFixBundle.message("fix.replace.with.x", replacement));
  }
###END###
  protected @NotNull LocalInspectionTool getInspection() {
    return new RegExpSimplifiableInspection();
  }
###END###
  public void testVeryEmpty() {
    quickfixTest("<warning descr=\"Empty branch in alternation\">|</warning>", "", "Remove empty branch");
  }
###END###
  public void testEmptyLeft() {
    highlightTest("|right");
  }
###END###
  public void testEmptyRight() {
    highlightTest("left|");
  }
###END###
  public void testEmptyLeftAndRight() {
    quickfixTest("|m<warning descr=\"Empty branch in alternation\">|<caret></warning>", "|m", "Remove empty branch");
  }
###END###
  public void testEmptyMiddle() {
    quickfixTest("a<warning descr=\"Empty branch in alternation\"><caret>|</warning>|b", "a|b", "Remove empty branch");
  }
###END###
  public void testLogbackUnit() {
    highlightTest("(|kb|mb|gb)s?");
  }
###END###
  protected LocalInspectionTool getInspection() {
    return new EmptyAlternationBranchInspection();
  }
###END###
  protected abstract LocalInspectionTool getInspection();

  protected void highlightTest(@Language("RegExp") String code) {
    highlightTest(code, RegExpFileType.INSTANCE);
  }
###END###
  protected void highlightTest(@Language("RegExp") String code) {
    highlightTest(code, RegExpFileType.INSTANCE);
  }
###END###
  protected void highlightTest(@Language("RegExp") String code, FileType fileType) {
    final LocalInspectionTool inspection = getInspection();
    myFixture.enableInspections(inspection);
    final HighlightDisplayKey displayKey = HighlightDisplayKey.find(inspection.getShortName());
    if (displayKey != null) {
      final Project project = myFixture.getProject();
      final InspectionProfileImpl currentProfile = ProjectInspectionProfileManager.getInstance(project).getCurrentProfile();
      final HighlightDisplayLevel errorLevel = currentProfile.getErrorLevel(displayKey, null);
      if (errorLevel == HighlightDisplayLevel.DO_NOT_SHOW) {
        currentProfile.setErrorLevel(displayKey, HighlightDisplayLevel.WARNING, project);
      }
    }
    myFixture.configureByText(fileType, code);
    myFixture.testHighlighting();
  }
###END###
  protected void quickfixTest(@Language("RegExp") String before, @Language("RegExp") String after, String hint) {
    quickfixTest(before, after, hint, RegExpFileType.INSTANCE);
  }
###END###
  protected void quickfixTest(@Language("RegExp") String before, @Language("RegExp") String after, String hint, FileType fileType) {
    highlightTest(before, fileType);
    myFixture.launchAction(myFixture.findSingleIntention(hint));
    myFixture.checkResult(after);
  }
###END###
  protected final void quickfixAllTest(@Language("RegExp") String before, @Language("RegExp") String after) {
    InspectionProfileEntry inspection = getInspection();
    quickfixTest(before, after, InspectionsBundle.message("fix.all.inspection.problems.in.file", inspection.getDisplayName()));
  }
###END###
  public void testConjunction() {
    quickfixTest("[a<warning descr=\"Redundant nested character class\"><caret>[</warning>b]]", "[ab]",
                 RegExpBundle.message("inspection.quick.fix.replace.redundant.character.class.with.contents"));
  }
###END###
  public void testIntersection() {
    quickfixTest("[a-z&&<warning descr=\"Redundant nested character class\"><caret>[</warning>aeoiuy]]", "[a-z&&aeoiuy]",
                 RegExpBundle.message("inspection.quick.fix.replace.redundant.character.class.with.contents"));
  }
###END###
  public void testNegation() {
    highlightTest("[^abc[^cde]]");
    // JDK 8: conjunction of inverted [abc] and inverted [cde], which equals inverted [c]
    // JDK 9: the inverse of the conjunction of [abc] and inverted [cde], which equals the inverse of inverted [de], which is [de]
  }
###END###
  public void testNoWarn() {
    highlightTest("[a-z&&[^aeouiy]]" ); // intersection of [a-z] with [aeouiy] inverted, which equals the  alphabet except vowels
  }
###END###
  public void testNoWarn2() {
    highlightTest("[^a[abc]]");
    // JDK 8: conjunction of inverted [a] and [abc], which equals [bc]
    // JDK 9: inverted conjunction of [a] and [abc], which equals inverted [abc]
  }
###END###
  public void testNegatedIntersection() {
    highlightTest("[^a&&[^abc]]");
    // JDK 8: intersection of inverted [a] and inverted [abc], which equals inverted [abc]
    // JDK 9: inverted intersection of [a] and inverted [abc], which equals inverted empty class, which matches everything
  }
###END###
  protected @NotNull LocalInspectionTool getInspection() {
    return new RedundantNestedCharacterClassInspection();
  }
###END###
  public void testSimple() {
    highlightTest("<warning descr=\"Single character alternation in RegExp\">a|b|c|d</warning>");
  }
###END###
  public void testNoWarn() {
    highlightTest("a|b|cc|d");
  }
###END###
  public void testNoWarnNoException() {
    highlightTest("(?i)x|y");
  }
###END###
  public void testQuickfix() {
    quickfixTest("<warning descr=\"Single character alternation in RegExp\">x|y|z</warning>", "[xyz]", "Replace with '[xyz]'");
  }
###END###
  public void testRemoveNonCapturingGroup() {
    quickfixTest("(?:<warning descr=\"Single character alternation in RegExp\">k<caret>|l|m</warning>)", "[klm]", "Replace with '[klm]'");
  }
###END###
  public void testEscapes() {
    quickfixTest("(<warning descr=\"Single character alternation in RegExp\">\\.|<caret>\\[|]|\\(|\\)|\\{|}|\\^|\\?|\\*|\\||\\+|-|\\$</warning>)ab",
                 "([.\\[\\](){}^?*|+\\-$])ab", "Replace with '[.\\[\\](){}^?*|+\\-$]'");
  }
###END###
  public void testRedundantEscapeReplacement() {
    quickfixTest("(<warning descr=\"Single character alternation in RegExp\">\\[<caret>|\\]</warning>)", "([\\[\\]])", "Replace with '[\\[\\]]");
  }
###END###
  public void testRedundantEscapeReplacement2() {
    quickfixTest("<warning descr=\"Single character alternation in RegExp\">\\+|\\-|\\*|/|=|<|>|\\[|\\]|\\.|,|:|;|\\(|\\^</warning>",
                 "[+\\-*/=<>\\[\\].,:;(^]",
                 "Replace with '[+\\-*/=<>\\[\\].,:;(^]'");
  }
###END###
  protected LocalInspectionTool getInspection() {
    return new SingleCharAlternationInspection();
  }
###END###
  public void testSimple() {
    quickfixTest("<warning descr=\"Escaped meta character '.'\">\\.</warning>", "[.]", "Replace with '[.]'");
  }
###END###
  public void testNoWarn() {
    highlightTest("\\[\\^\\]");
  }
###END###
  public void testHighlighting() {
    highlightTest("<warning descr=\"Escaped meta character '{'\">\\{</warning>" +
                  "\\}" + // already has redundant character escape warning
                  "<warning descr=\"Escaped meta character '('\">\\(</warning>" +
                  "<warning descr=\"Escaped meta character ')'\">\\)</warning>" +
                  "<warning descr=\"Escaped meta character '.'\">\\.</warning>" +
                  "<warning descr=\"Escaped meta character '*'\">\\*</warning>" +
                  "<warning descr=\"Escaped meta character '+'\">\\+</warning>" +
                  "<warning descr=\"Escaped meta character '?'\">\\?</warning>" +
                  "<warning descr=\"Escaped meta character '|'\">\\|</warning>" +
                  "<warning descr=\"Escaped meta character '$'\">\\$</warning>");
  }

  @NotNull
  @Override
  protected LocalInspectionTool getInspection() {
    return new EscapedMetaCharacterInspection();
  }
}
###END###
  protected LocalInspectionTool getInspection() {
    return new EscapedMetaCharacterInspection();
  }
###END###
  protected String getTestDataPath() {
    return PathManagerEx.getCommunityHomePath() + "/RegExpSupport/testData";
  }
###END###
  public void testDanglingMetaCharacter1() throws IOException {
    doCodeTest("{");
  }

  public void testDanglingMetaCharacter2() throws IOException {
    doCodeTest("}");
  }
###END###
  public void testDanglingMetaCharacter2() throws IOException {
    doCodeTest("}
###END###
  public void testDanglingMetaCharacter3() throws IOException {
    doCodeTest("]");
  }
###END###
  public void testEscapedMetaCharacter() throws IOException {
    //noinspection RegExpRedundantEscape
    doCodeTest("\\]");
  }
###END###
  public void testExtendedUnicode() throws IOException {
    doCodeTest("\\u{9}");
  }
###END###
  protected void lookAhead(@NotNull Lexer baseLexer) {
    final IElementType tokenType = baseLexer.getTokenType();
    if (!RegExpTT.CHARACTERS.contains(tokenType) && tokenType != RegExpTT.RBRACE) {
      advanceLexer(baseLexer);
      if (baseLexer.getTokenType() == RegExpTT.MINUS) {
        advanceAs(baseLexer, RegExpTT.CHARACTER);
      }
    }
    else {
      super.lookAhead(baseLexer);
    }
  }
###END###
    public void start(@NotNull CharSequence buffer, int startOffset, int endOffset, int initialState) {
      getFlex().commentMode = (initialState & COMMENT_MODE) != 0 || myCapabilities.contains(RegExpCapability.COMMENT_MODE);
      super.start(buffer, startOffset, endOffset, initialState & ~COMMENT_MODE);
    }
###END###
    public _RegExLexer getFlex() {
      return (_RegExLexer)super.getFlex();
    }
###END###
    public int getState() {
      final _RegExLexer flex = getFlex();
      int state = super.getState();
      if (flex.commentMode) {
        state |= COMMENT_MODE;
      }
      if (!flex.states.isEmpty()) {
        state |= NESTED_STATES;
      }
      if (flex.capturingGroupCount != 0) {
        state |= CAPTURING_GROUPS;
      }
      return state;
    }
###END###
    public void start(@NotNull CharSequence buffer, int startOffset, int endOffset, int initialState) {
      getFlex().commentMode = (initialState & COMMENT_MODE) != 0 || myCapabilities.contains(RegExpCapability.COMMENT_MODE);
      super.start(buffer, startOffset, endOffset, initialState & ~COMMENT_MODE);
    }
###END###
    public _RegExLexer getFlex() {
      return (_RegExLexer)super.getFlex();
    }
###END###
    public int getState() {
      final _RegExLexer flex = getFlex();
      int state = super.getState();
      if (flex.commentMode) {
        state |= COMMENT_MODE;
      }
      if (!flex.states.isEmpty()) {
        state |= NESTED_STATES;
      }
      if (flex.capturingGroupCount != 0) {
        state |= CAPTURING_GROUPS;
      }
      return state;
    }
###END###
  public FileType getFileType() {
    return RegExpFileType.INSTANCE;
  }
###END###
  public Collection<RegExpGroup> getGroups() {
    return PsiTreeUtil.findChildrenOfType(this, RegExpGroup.class);
  }
###END###
    public String getName() {
        return "RegExp";
    }
###END###
    public String getDescription() {
        return RegExpBundle.message("filetype.regular.expression.description");
    }
###END###
    public String getDefaultExtension() {
        return "regexp";
    }
###END###
    public Icon getIcon() {
        return getLanguage() == RegExpLanguage.INSTANCE ? AllIcons.FileTypes.Regexp : null;
    }
###END###
    public static LanguageFileType forLanguage(@NotNull Language language) {
        return new RegExpFileType(language);
    }
###END###
  public boolean value(@NotNull PsiElement element) {
    final ASTNode node = element.getNode();
    if ((node != null && node.getElementType() == RegExpTT.CHARACTER) ||
        (element instanceof RegExpChar && ((RegExpChar)element).getType() == RegExpChar.Type.CHAR)) {
      return false;
    }
    return true;
  }
###END###
  protected ASTNode doParseContents(@NotNull ASTNode chameleon, @NotNull PsiElement outerPsi) {
    PsiElement psi = chameleon.getPsi();
    Project project = psi.getProject();
    Language languageForParser = getLanguageForParser(psi);
    RegExpParserDefinition definition = (RegExpParserDefinition)LanguageParserDefinitions.INSTANCE.forLanguage(languageForParser);
    EnumSet<RegExpCapability> capabilities = setupCapabilities(psi, EnumSet.copyOf(definition.getDefaultCapabilities()));
    RegExpLexer lexer = definition.createLexer(project, capabilities);
    PsiParser parser = definition.createParser(project, capabilities);
    PsiBuilder builder = PsiBuilderFactory.getInstance().createBuilder(project, chameleon, lexer, languageForParser, chameleon.getChars());
    var startTime = System.nanoTime();
    ((LightPsiParser)parser).parseLight(this, builder);
    var result = builder.getTreeBuilt().getFirstChildNode();
    ParsingDiagnostics.registerParse(builder, getLanguage(), System.nanoTime() - startTime);
    return result;
  }
###END###
  private static EnumSet<RegExpCapability> setupCapabilities(PsiElement psi, @NotNull EnumSet<RegExpCapability> capabilities) {
    PsiElement host = InjectedLanguageUtil.findInjectionHost(psi);
    if (host == null && !(psi instanceof PsiFile)) host = psi.getParent();
    Language language = host == null ? null : host.getLanguage();
    RegExpCapabilitiesProvider provider = language == null ? null : RegExpCapabilitiesProvider.EP.forLanguage(language);
    return provider == null ? capabilities : EnumSet.copyOf(provider.setup(host, capabilities));
  }
###END###
  protected SyntaxHighlighter createHighlighter() {
    return new RegExpHighlighter(null, myParserDefinition);
  }
###END###
    public EnumSet<RegExpCapability> getDefaultCapabilities() {
        return RegExpCapability.DEFAULT_CAPABILITIES;
    }
###END###
    public Lexer createLexer(Project project) {
        return createLexer(project, getDefaultCapabilities());
    }
###END###
    public @NotNull PsiParser createParser(Project project) {
      return createParser(project, getDefaultCapabilities());
    }
###END###
    public RegExpParser createParser(Project project, @NotNull EnumSet<RegExpCapability> capabilities) {
        return new RegExpParser(capabilities);
    }
###END###
    public RegExpLexer createLexer(Project project, @NotNull EnumSet<RegExpCapability> capabilities) {
        return new RegExpLexer(capabilities);
    }
###END###
  public @NotNull IFileElementType getFileNodeType() {
    return REGEXP_FILE;
  }
###END###
    public TokenSet getWhitespaceTokens() {
        return TokenSet.create(RegExpTT.QUOTE_BEGIN, RegExpTT.QUOTE_END, TokenType.WHITE_SPACE);
    }
###END###
    public TokenSet getStringLiteralElements() {
        return TokenSet.EMPTY;
    }
###END###
    public TokenSet getCommentTokens() {
        return TokenSet.create(RegExpTT.COMMENT);
    }
###END###
    public PsiElement createElement(ASTNode node) {
        final IElementType type = node.getElementType();
        if (type == RegExpElementTypes.PATTERN) {
            return new RegExpPatternImpl(node);
        } else if (type == RegExpElementTypes.BRANCH) {
            return new RegExpBranchImpl(node);
        } else if (type == RegExpElementTypes.SIMPLE_CLASS) {
            return new RegExpSimpleClassImpl(node);
        } else if (type == RegExpElementTypes.CLASS) {
            return new RegExpClassImpl(node);
        } else if (type == RegExpElementTypes.CHAR_RANGE) {
            return new RegExpCharRangeImpl(node);
        } else if (type == RegExpElementTypes.CHAR) {
            return new RegExpCharImpl(node);
        } else if (type == RegExpElementTypes.GROUP) {
            return new RegExpGroupImpl(node);
        } else if (type == RegExpElementTypes.PROPERTY) {
            return new RegExpPropertyImpl(node);
        } else if (type == RegExpElementTypes.NAMED_CHARACTER) {
            return new RegExpNamedCharacterImpl(node);
        } else if (type == RegExpElementTypes.SET_OPTIONS) {
            return new RegExpSetOptionsImpl(node);
        } else if (type == RegExpElementTypes.OPTIONS) {
            return new RegExpOptionsImpl(node);
        } else if (type == RegExpElementTypes.BACKREF) {                                    
            return new RegExpBackrefImpl(node);
        } else if (type == RegExpElementTypes.CLOSURE) {
            return new RegExpClosureImpl(node);
        } else if (type == RegExpElementTypes.QUANTIFIER) {
            return new RegExpQuantifierImpl(node);
        } else if (type == RegExpElementTypes.BOUNDARY) {
            return new RegExpBoundaryImpl(node);
        } else if (type == RegExpElementTypes.INTERSECTION) {
            return new RegExpIntersectionImpl(node);
        } else if (type == RegExpElementTypes.NAMED_GROUP_REF) {
            return new RegExpNamedGroupRefImpl(node);
        } else if (type == RegExpElementTypes.CONDITIONAL) {
            return new RegExpConditionalImpl(node);
        } else if (type == RegExpElementTypes.POSIX_BRACKET_EXPRESSION) {
            return new RegExpPosixBracketExpressionImpl(node);
        } else if (type == RegExpElementTypes.NUMBER) {
            return new RegExpNumberImpl(node);
        }
      
        return new ASTWrapperPsiElement(node);
    }
###END###
  public @NotNull PsiFile createFile(@NotNull FileViewProvider viewProvider) {
    return new RegExpFile(viewProvider, RegExpLanguage.INSTANCE);
  }
###END###
  public @NotNull SpaceRequirements spaceExistenceTypeBetweenTokens(ASTNode left, ASTNode right) {
    return SpaceRequirements.MUST_NOT;
  }
###END###
  public static void iterate(Consumer<? super String> consumer) {
    try {
      final Class<?> aClass = Class.forName("java.lang.CharacterName");
      final Method initNamePool = ReflectionUtil.getDeclaredMethod(aClass, "initNamePool");
      if (initNamePool != null) { // jdk 8
        byte[] namePool = (byte[])initNamePool.invoke(null); // initializes "lookup" field
        final int[][] lookup2d = ReflectionUtil.getStaticFieldValue(aClass, int[][].class, "lookup");
        if (lookup2d == null) {
          return;
        }
        for (int[] indexes : lookup2d) {
          if (indexes != null) {
            for (int index : indexes) {
              if (index != 0) {
                final String name = new String(namePool, index >>> 8, index & 0xff, StandardCharsets.US_ASCII);
                consumer.accept(name);
              }
            }
          }
        }
      }
      else {
        final Method instance = ReflectionUtil.getDeclaredMethod(aClass, "getInstance");
        final Field field1 = ReflectionUtil.getDeclaredField(aClass, "strPool");
        final Field field2 = ReflectionUtil.getDeclaredField(aClass, "lookup");
        if (instance != null && field1 != null && field2 != null) { // jdk 9
          final Object characterName = instance.invoke(null);
          byte[] namePool = (byte[])field1.get(characterName);
          final int[] lookup = (int[])field2.get(characterName);
          for (int index : lookup) {
            if (index != 0) {
              final String name = new String(namePool, index >>> 8, index & 0xff, StandardCharsets.US_ASCII);
              consumer.accept(name);
            }
          }
        }
      }
    }
    catch (ClassNotFoundException | InvocationTargetException | IllegalAccessException e) {
      throw new RuntimeException(e);
    }
  }
###END###
  public static int getCodePoint(String name) {
    if (name == null) {
      return -1;
    }
    final Method method = ReflectionUtil.getMethod(Character.class, "codePointOf", String.class); // jdk 9 method
    if (method != null) {
      try {
        return (int)method.invoke(null, name);
      }
      catch (IllegalArgumentException e) {
        return -1;
      }
      catch (InvocationTargetException e) {
        if (e.getCause() instanceof IllegalArgumentException) {
          return -1;
        }
        throw new RuntimeException(e);
      }
      catch (IllegalAccessException e) {
        throw new RuntimeException(e);
      }
    }
    try {
      // jdk 8 fallback
      final Class<?> aClass = Class.forName("java.lang.CharacterName");
      final Method initNamePool = ReflectionUtil.getDeclaredMethod(aClass, "initNamePool");
      if (initNamePool == null) {
        return -1; // give up
      }
      byte[] namePool = (byte[])initNamePool.invoke(null);
      name = StringUtil.toUpperCase(name.trim());
      byte[] key = name.getBytes(StandardCharsets.ISO_8859_1);
      final int[][] lookup = ReflectionUtil.getField(aClass, null, int[][].class, "lookup");
      if (lookup == null) throw new RuntimeException();
      for (int i = 0; i < lookup.length; i++) {
        int[] indexes = lookup[i];
        if (indexes != null) {
          for (int j = 0; j < indexes.length; j++) {
            int index = indexes[j];
            if ((index & 0xFF) == key.length && matches(namePool, index >>> 8, key)) {
              return i << 8 | j;
            }
          }
        }
      }
      return getUnnamedUnicodeCharacterCodePoint(name);
    }
    catch (ClassNotFoundException | InvocationTargetException | IllegalAccessException e) {
      throw new RuntimeException(e);
    }
  }
###END###
  private static int getUnnamedUnicodeCharacterCodePoint(String name) {
    int index = name.lastIndexOf(' ');
    if (index != -1) {
      try {
        int c = Integer.parseInt(name.substring(index + 1), 16);
        if (Character.isValidCodePoint(c) && name.equals(Character.getName(c))) return c;
      }
      catch (NumberFormatException ignore) {
      }
    }
    return -1;
  }
###END###
  private static boolean matches(byte[] bytes, int offset, byte[] key) {
    if (offset < 0 || offset + key.length > bytes.length) {
      throw new IllegalArgumentException();
    }
    for (int i = 0; i < key.length; i++) {
      if (bytes[i + offset] != key[i]) {
        return false;
      }
    }
    return true;
  }
###END###
  public void annotate(@NotNull PsiElement psiElement, @NotNull AnnotationHolder holder) {
    assert myHolder == null : "unsupported concurrent annotator invocation";
    try {
      myHolder = holder;
      psiElement.accept(this);
    }
    finally {
      myHolder = null;
    }
  }
###END###
  public void visitRegExpSetOptions(RegExpSetOptions options) {
    checkValidFlag(options.getOnOptions(), false);
    checkValidFlag(options.getOffOptions(), true);
  }
###END###
  private void checkValidFlag(@Nullable RegExpOptions options, boolean skipMinus) {
    if (options == null) {
      return;
    }
    final String text = options.getText();
    final int start = skipMinus ? 1 : 0; // skip '-' if necessary
    for (int i = start, length = text.length(); i < length; i++) {
      final int c = text.codePointAt(i);
      if (!Character.isBmpCodePoint(c) || !myLanguageHosts.supportsInlineOptionFlag((char)c, options)) {
        final int offset = options.getTextOffset() + i;
        myHolder.newAnnotation(HighlightSeverity.ERROR, RegExpBundle.message("error.unknown.inline.option.flag"))
          .range(new TextRange(offset, offset + 1)).create();
      }
    }
  }
###END###
  public void visitRegExpCharRange(RegExpCharRange range) {
    final RegExpChar from = range.getFrom();
    final PsiElement hyphen = from.getNextSibling();
    myHolder.newSilentAnnotation(HighlightInfoType.SYMBOL_TYPE_SEVERITY).range(hyphen).textAttributes(RegExpHighlighter.META).create();
    final RegExpChar to = range.getTo();
    if (to == null) {
      return;
    }
    final int fromCodePoint = from.getValue();
    final int toCodePoint = to.getValue();
    if (fromCodePoint == -1 || toCodePoint == -1) {
      return;
    }
    if (toCodePoint < fromCodePoint) {
      myHolder.newAnnotation(HighlightSeverity.ERROR, RegExpBundle.message("error.illegal.character.range.to.from")).range(range).create();
    }
  }
###END###
  public void visitRegExpBoundary(RegExpBoundary boundary) {
    if (!myLanguageHosts.supportsBoundary(boundary)) {
      myHolder.newAnnotation(HighlightSeverity.ERROR, RegExpBundle.message("error.this.boundary.is.not.supported.in.this.regex.dialect"))
        .create();
    }
  }
###END###
  public void visitSimpleClass(RegExpSimpleClass simpleClass) {
    if (!myLanguageHosts.supportsSimpleClass(simpleClass)) {
      myHolder.newAnnotation(HighlightSeverity.ERROR, RegExpBundle.message("error.illegal.unsupported.escape.sequence")).create();
    }
  }
###END###
  public void visitRegExpChar(final RegExpChar ch) {
    final PsiElement child = ch.getFirstChild();
    final IElementType type = child.getNode().getElementType();
    if (type == RegExpTT.CHARACTER) {
      if (ch.getTextLength() > 1) {
        myHolder.newSilentAnnotation(HighlightInfoType.SYMBOL_TYPE_SEVERITY)
          .range(ch)
          .textAttributes(RegExpHighlighter.ESC_CHARACTER)
          .create();
      }
    }
    else if (type == StringEscapesTokenTypes.INVALID_CHARACTER_ESCAPE_TOKEN) {
      myHolder.newAnnotation(HighlightSeverity.ERROR, RegExpBundle.message("error.illegal.unsupported.escape.sequence")).create();
      return;
    }
    else if (type == RegExpTT.BAD_HEX_VALUE) {
      myHolder.newAnnotation(HighlightSeverity.ERROR, RegExpBundle.message("error.illegal.hexadecimal.escape.sequence")).create();
      return;
    }
    else if (type == RegExpTT.BAD_OCT_VALUE) {
      myHolder.newAnnotation(HighlightSeverity.ERROR, RegExpBundle.message("error.illegal.octal.escape.sequence")).create();
      return;
    }
    else if (type == StringEscapesTokenTypes.INVALID_UNICODE_ESCAPE_TOKEN) {
      myHolder.newAnnotation(HighlightSeverity.ERROR, RegExpBundle.message("error.illegal.unicode.escape.sequence")).create();
      return;
    }
    final String text = ch.getUnescapedText();
    if (type == RegExpTT.ESC_CTRL_CHARACTER && text.equals("\\b") && !myLanguageHosts.supportsLiteralBackspace(ch)) {
      myHolder.newAnnotation(HighlightSeverity.ERROR, RegExpBundle.message("error.illegal.unsupported.escape.sequence")).create();
    }
    final RegExpChar.Type charType = ch.getType();
    if (charType == RegExpChar.Type.HEX || charType == RegExpChar.Type.UNICODE) {
      if (ch.getValue() == -1) {
        myHolder.newAnnotation(HighlightSeverity.ERROR, RegExpBundle.message("error.illegal.unicode.escape.sequence")).create();
        return;
      }
      if (text.charAt(text.length() - 1) == '}') {
        if (!myLanguageHosts.supportsExtendedHexCharacter(ch)) {
          myHolder.newAnnotation(HighlightSeverity.ERROR,
                                 RegExpBundle.message("error.this.hex.character.syntax.is.not.supported.in.this.regex.dialect")).create();
        }
      }
    }
###END###
  public void visitRegExpProperty(RegExpProperty property) {
    final ASTNode category = property.getCategoryNode();
    if (category == null) {
      return;
    }
    if (!myLanguageHosts.supportsPropertySyntax(property)) {
      myHolder.newAnnotation(HighlightSeverity.ERROR,
                             RegExpBundle.message("error.property.escape.sequences.are.not.supported.in.this.regex.dialect")).create();
      return;
    }
    final String propertyName = category.getText();
    final ASTNode next = category.getTreeNext();
    if (next == null || next.getElementType() != RegExpTT.EQ) {
      if(!myLanguageHosts.isValidCategory(category.getPsi(), propertyName)) {
        myHolder.newAnnotation(HighlightSeverity.ERROR, RegExpBundle.message("error.unknown.character.category")).range(category)
        .highlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL).create();
      }
    }
    else {
      if(!myLanguageHosts.isValidPropertyName(category.getPsi(), propertyName)) {
        myHolder.newAnnotation(HighlightSeverity.ERROR, RegExpBundle.message("error.unknown.property.name")).range(category)
        .highlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL).create();
        return;
      }
      final ASTNode valueNode = property.getValueNode();
      if (valueNode != null && !myLanguageHosts.isValidPropertyValue(category.getPsi(), propertyName, valueNode.getText())) {
        myHolder.newAnnotation(HighlightSeverity.ERROR, RegExpBundle.message("error.unknown.property.value")).range(valueNode)
        .highlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL).create();
      }
    }
  }
###END###
  public void visitRegExpNamedCharacter(RegExpNamedCharacter namedCharacter) {
    if (!myLanguageHosts.supportsNamedCharacters(namedCharacter)) {
      myHolder.newAnnotation(HighlightSeverity.ERROR,
                             RegExpBundle.message("error.named.unicode.characters.are.not.allowed.in.this.regex.dialect")).create();
    }
    else if (!myLanguageHosts.isValidNamedCharacter(namedCharacter)) {
      final ASTNode node = namedCharacter.getNameNode();
      if (node != null) {
        myHolder.newAnnotation(HighlightSeverity.ERROR, RegExpBundle.message("error.unknown.character.name")).range(node)
        .highlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL).create();
      }
    }
  }
###END###
  public void visitRegExpBackref(final RegExpBackref backref) {
    final RegExpGroup group = backref.resolve();
    if (group == null) {
      myHolder.newAnnotation(HighlightSeverity.ERROR, RegExpBundle.message("error.unresolved.back.reference"))
      .highlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL).create();
    }
    else if (PsiTreeUtil.isAncestor(group, backref, true)) {
      myHolder.newAnnotation(HighlightSeverity.WARNING,
                             RegExpBundle.message("error.back.reference.is.nested.into.the.capturing.group.it.refers.to")).create();
    }
  }
###END###
  public void visitRegExpGroup(RegExpGroup group) {
    if (RegExpGroupImpl.isPcreConditionalGroup(group.getNode())) {
      if (RegExpGroupImpl.isPcreDefine(group.getNode())) {
        RegExpConditional conditional = ObjectUtils.tryCast(group.getParent(), RegExpConditional.class);
        if (conditional != null) {
          RegExpBranch[] branches = PsiTreeUtil.getChildrenOfType(conditional, RegExpBranch.class);
          if (branches != null && branches.length > 1) {
            myHolder.newAnnotation(HighlightSeverity.ERROR,
                                   RegExpBundle.message("error.define.subpattern.contains.more.than.one.branch")).create();
          }
        }
      }
      return;
    }
    final RegExpPattern pattern = group.getPattern();
    final RegExpBranch[] branches = pattern.getBranches();
    if (isEmpty(branches) && group.getNode().getLastChildNode().getElementType() == RegExpTT.GROUP_END) {
      // catches "()" as well as "(|)"
      myHolder.newAnnotation(HighlightSeverity.WARNING, RegExpBundle.message("error.empty.group")).create();
    }
    else if (branches.length == 1) {
      final RegExpAtom[] atoms = branches[0].getAtoms();
      if (atoms.length == 1 && atoms[0] instanceof RegExpGroup) {
        final RegExpGroup.Type type = group.getType();
        if (type == RegExpGroup.Type.CAPTURING_GROUP || type == RegExpGroup.Type.ATOMIC || type == RegExpGroup.Type.NON_CAPTURING) {
          final RegExpGroup innerGroup = (RegExpGroup)atoms[0];
          if (group.isCapturing() == innerGroup.isCapturing()) {
            myHolder.newAnnotation(HighlightSeverity.WARNING, RegExpBundle.message("error.redundant.group.nesting")).create();
          }
        }
      }
    }
    if (group.isAnyNamedGroup()) {
      if (!myLanguageHosts.supportsNamedGroupSyntax(group)) {
        myHolder.newAnnotation(HighlightSeverity.ERROR,
                               RegExpBundle.message("error.this.named.group.syntax.is.not.supported.in.this.regex.dialect")).create();
      }
    }
    if (group.getType() == RegExpGroup.Type.ATOMIC && !myLanguageHosts.supportsPossessiveQuantifiers(group)) {
      myHolder.newAnnotation(HighlightSeverity.ERROR, RegExpBundle.message("error.atomic.groups.are.not.supported.in.this.regex.dialect"))
        .create();
    }
    final String name = group.getName();
    if (name != null && !myLanguageHosts.isValidGroupName(name, group)) {
      final ASTNode node = group.getNode().findChildByType(RegExpTT.NAME);
      if (node != null) myHolder.newAnnotation(HighlightSeverity.ERROR, RegExpBundle.message("error.invalid.group.name")).range(node)
        .create();
    }
    final AnnotationSession session = myHolder.getCurrentAnnotationSession();
    final Map<String, RegExpGroup> namedGroups = NAMED_GROUP_MAP.get(session, new HashMap<>());
    if (namedGroups.isEmpty()) session.putUserData(NAMED_GROUP_MAP, namedGroups);
    if (namedGroups.put(name, group) != null && !myLanguageHosts.isDuplicateGroupNamesAllowed(group)) {
      final ASTNode node = group.getNode().findChildByType(RegExpTT.NAME);
      if (node != null) myHolder.newAnnotation(HighlightSeverity.ERROR,
                                               RegExpBundle.message("error.group.with.name.0.already.defined", name)).range(node).create();
    }
    final RegExpGroup.Type groupType = group.getType();
    if (groupType == RegExpGroup.Type.POSITIVE_LOOKBEHIND || groupType == RegExpGroup.Type.NEGATIVE_LOOKBEHIND) {
      final RegExpLanguageHost.Lookbehind support = myLanguageHosts.supportsLookbehind(group);
      if (support == RegExpLanguageHost.Lookbehind.NOT_SUPPORTED) {
        myHolder.newAnnotation(HighlightSeverity.ERROR,
                               RegExpBundle.message("error.look.behind.groups.are.not.supported.in.this.regex.dialect")).create();
      }
      else {
        group.accept(new LookbehindVisitor(support, myHolder));
      }
    }
  }
###END###
  public void visitRegExpNamedGroupRef(RegExpNamedGroupRef groupRef) {
    if (!(groupRef.getParent() instanceof RegExpConditional) && !myLanguageHosts.supportsNamedGroupRefSyntax(groupRef)) {
      myHolder.newAnnotation(HighlightSeverity.ERROR,
                             RegExpBundle.message("error.this.named.group.reference.syntax.is.not.supported.in.this.regex.dialect"))
        .create();
      return;
    }
    if (groupRef.getGroupName() == null) {
      return;
    }
    final RegExpGroup group = groupRef.resolve();
    if (group == null) {
      final ASTNode node = groupRef.getNode().findChildByType(RegExpTT.NAME);
      if (node != null) {
        myHolder.newAnnotation(HighlightSeverity.ERROR, RegExpBundle.message("error.unresolved.named.group.reference")).range(node)
        .highlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL).create();
      }
    }
    else if (PsiTreeUtil.isAncestor(group, groupRef, true)) {
      myHolder.newAnnotation(HighlightSeverity.WARNING,
                             RegExpBundle.message("error.group.reference.is.nested.into.the.named.group.it.refers.to")).create();
    }
  }
###END###
  public void visitComment(@NotNull PsiComment comment) {
    if (comment.getText().startsWith("(?#")) {
      if (!myLanguageHosts.supportsPerl5EmbeddedComments(comment)) {
        myHolder.newAnnotation(HighlightSeverity.ERROR,
                               RegExpBundle.message("error.embedded.comments.are.not.supported.in.this.regex.dialect")).create();
      }
    }
  }
###END###
  public void visitRegExpConditional(RegExpConditional conditional) {
    if (!myLanguageHosts.supportsConditionals(conditional)) {
      myHolder.newAnnotation(HighlightSeverity.ERROR,
                             RegExpBundle.message("error.conditionals.are.not.supported.in.this.regex.dialect")).create();
    }
    final RegExpAtom condition = conditional.getCondition();
    if (!myLanguageHosts.supportConditionalCondition(condition)) {
      if (condition instanceof RegExpGroup) {
        myHolder.newAnnotation(HighlightSeverity.ERROR,
                               RegExpBundle.message("error.lookaround.conditions.in.conditionals.not.supported.in.this.regex.dialect"))
          .range(condition)
          .create();
      }
      else if (condition != null) {
        final ASTNode child = condition.getNode().getFirstChildNode();
        final IElementType type = child.getElementType();
        if (type == RegExpTT.QUOTED_CONDITION_BEGIN || type == RegExpTT.GROUP_BEGIN || type == RegExpTT.ANGLE_BRACKET_CONDITION_BEGIN) {
          myHolder.newAnnotation(HighlightSeverity.ERROR,
                                 RegExpBundle.message("error.this.kind.group.reference.condition.not.supported.in.this.regex.dialect"))
            .range(condition)
            .create();
        }
      }
    }
  }
###END###
  private static boolean isEmpty(RegExpBranch[] branches) {
    return !ContainerUtil.exists(branches, branch -> branch.getAtoms().length > 0);
  }
###END###
  public void visitRegExpClosure(RegExpClosure closure) {
    if (closure.getAtom() instanceof RegExpSetOptions) {
      final RegExpQuantifier quantifier = closure.getQuantifier();
      myHolder.newAnnotation(HighlightSeverity.ERROR, RegExpBundle.message("error.dangling.metacharacter", quantifier.getUnescapedText()))
        .range(quantifier)
        .create();
    }
  }
###END###
  public void visitRegExpQuantifier(RegExpQuantifier quantifier) {
    if (quantifier.isCounted()) {
      final RegExpNumber minElement = quantifier.getMin();
      final RegExpNumber maxElement = quantifier.getMax();
      Number minValue = null;
      if (minElement != null) {
        minValue = myLanguageHosts.getQuantifierValue(minElement);
        if (minValue == null) myHolder.newAnnotation(HighlightSeverity.ERROR, RegExpBundle.message("error.repetition.value.too.large"))
          .range(minElement).create();
      }
      Number maxValue = null;
      if (maxElement != null && minElement != maxElement) {
        maxValue= myLanguageHosts.getQuantifierValue(maxElement);
        if (maxValue == null) myHolder.newAnnotation(HighlightSeverity.ERROR, RegExpBundle.message("error.repetition.value.too.large"))
          .range(maxElement).create();
      }
      if (minValue != null && maxValue != null) {
        if (minValue.longValue() > maxValue.longValue() || minValue.doubleValue() > maxValue.doubleValue()) {
          final TextRange range = new TextRange(minElement.getTextOffset(), maxElement.getTextOffset() + maxElement.getTextLength());
          myHolder.newAnnotation(HighlightSeverity.ERROR, RegExpBundle.message("error.illegal.repetition.range.min.max")).range(range)
            .create();
        }
      }
    }
    if (quantifier.isPossessive() && !myLanguageHosts.supportsPossessiveQuantifiers(quantifier)) {
      final ASTNode modifier = quantifier.getModifier();
      assert modifier != null;
      myHolder.newAnnotation(HighlightSeverity.ERROR, RegExpBundle.message("error.nested.quantifier.in.regexp")).range(modifier).create();
    }
  }
###END###
  public void visitPosixBracketExpression(RegExpPosixBracketExpression posixBracketExpression) {
    final String className = posixBracketExpression.getClassName();
    if (!POSIX_CHARACTER_CLASSES.contains(className) && !"<".equals(className) && !">".equals(className)) {
      final ASTNode node = posixBracketExpression.getNode().findChildByType(RegExpTT.NAME);
      if (node != null) {
        myHolder.newAnnotation(HighlightSeverity.ERROR, RegExpBundle.message("error.unknown.posix.character.class")).range(node)
        .highlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL).create();
      }
    }
  }
###END###
    public void visitRegExpElement(RegExpElement element) {
      if (myStop) {
        return;
      }
      super.visitRegExpElement(element);
    }
###END###
    public void visitRegExpChar(RegExpChar ch) {
      super.visitRegExpChar(ch);
      myLength++;
    }
###END###
    public void visitSimpleClass(RegExpSimpleClass simpleClass) {
      super.visitSimpleClass(simpleClass);
      myLength++;
    }
###END###
    public void visitRegExpClass(RegExpClass regExpClass) {
      myLength++;
    }
###END###
    public void visitRegExpProperty(RegExpProperty property) {
      super.visitRegExpProperty(property);
      myLength++;
    }
###END###
    public void visitRegExpBackref(RegExpBackref backref) {
      super.visitRegExpBackref(backref);
      if (mySupport != RegExpLanguageHost.Lookbehind.FULL) {
        stopAndReportError(backref, RegExpBundle.message("error.group.reference.not.allowed.inside.lookbehind"));
      }
    }
###END###
    public void visitRegExpPattern(RegExpPattern pattern) {
      if (mySupport != RegExpLanguageHost.Lookbehind.FIXED_LENGTH_ALTERNATION) {
        super.visitRegExpPattern(pattern);
        return;
      }
      final int length = myLength;
      int branchLength = -1;
      final RegExpBranch[] branches = pattern.getBranches();
      for (RegExpBranch branch : branches) {
        myLength = 0;
        super.visitRegExpBranch(branch);
        if (branchLength == -1) {
          branchLength = myLength;
        } else if (branchLength != myLength) {
          stopAndReportError(pattern,
                             RegExpBundle.message("error.alternation.alternatives.needs.to.have.the.same.length.inside.lookbehind"));
          return;
        }
      }
      myLength = length + branchLength;
    }
###END###
    public void visitRegExpClosure(RegExpClosure closure) {
      if (mySupport == RegExpLanguageHost.Lookbehind.FULL) {
        return;
      }
      final RegExpQuantifier quantifier = closure.getQuantifier();
      if (quantifier.isCounted()) {
        if (mySupport == RegExpLanguageHost.Lookbehind.FIXED_LENGTH_ALTERNATION ||
          mySupport == RegExpLanguageHost.Lookbehind.VARIABLE_LENGTH_ALTERNATION) {
          final RegExpNumber minElement = quantifier.getMin();
          final RegExpNumber maxElement = quantifier.getMax();
          if (minElement != null && maxElement != null) {
            final Number min = minElement.getValue();
            if (min == null) {
              myStop = true;
              return;
            }
            final Number max = maxElement.getValue();
            if (min.equals(max)) {
              final int length = myLength;
              myLength = 0;
              final RegExpAtom atom = closure.getAtom();
              atom.accept(this);
              final int atomLength = myLength;
              myLength = length + (atomLength * min.intValue());
              return;
            }
          }
          stopAndReportError(quantifier,
                             RegExpBundle.message("error.unequal.min.and.max.in.counted.quantifier.not.allowed.inside.lookbehind"));
        }
      }
      else {
        final ASTNode token = quantifier.getToken();
        assert token != null;
        if (token.getElementType().equals(RegExpTT.QUEST) && mySupport == RegExpLanguageHost.Lookbehind.FINITE_REPETITION) {
          return;
        }
        stopAndReportError(quantifier, RegExpBundle.message("error.0.repetition.not.allowed.inside.lookbehind", quantifier.getText()));
      }
    }
###END###
    public void visitRegExpNamedGroupRef(RegExpNamedGroupRef groupRef) {
      super.visitRegExpNamedGroupRef(groupRef);
      if (mySupport != RegExpLanguageHost.Lookbehind.FULL) {
        stopAndReportError(groupRef, RegExpBundle.message("error.named.group.reference.not.allowed.inside.lookbehind"));
      }
    }
###END###
    public void visitRegExpConditional(RegExpConditional conditional) {
      super.visitRegExpConditional(conditional);
      if (mySupport != RegExpLanguageHost.Lookbehind.FULL) {
        stopAndReportError(conditional, RegExpBundle.message("error.conditional.group.reference.not.allowed.inside.lookbehind"));
      }
    }
###END###
    public void visitPosixBracketExpression(RegExpPosixBracketExpression posixBracketExpression) {
      super.visitPosixBracketExpression(posixBracketExpression);
      myLength++;
    }
###END###
    public void stopAndReportError(RegExpElement element, @NotNull @Nls String message) {
      myHolder.newAnnotation(HighlightSeverity.ERROR, message).range(element).create();
      myStop = true;
    }
###END###
    public void visitRegExpElement(RegExpElement element) {
      if (myStop) {
        return;
      }
      super.visitRegExpElement(element);
    }
###END###
    public void visitRegExpChar(RegExpChar ch) {
      super.visitRegExpChar(ch);
      myLength++;
    }
###END###
    public void visitSimpleClass(RegExpSimpleClass simpleClass) {
      super.visitSimpleClass(simpleClass);
      myLength++;
    }
###END###
    public void visitRegExpClass(RegExpClass regExpClass) {
      myLength++;
    }
###END###
    public void visitRegExpProperty(RegExpProperty property) {
      super.visitRegExpProperty(property);
      myLength++;
    }
###END###
    public void visitRegExpBackref(RegExpBackref backref) {
      super.visitRegExpBackref(backref);
      if (mySupport != RegExpLanguageHost.Lookbehind.FULL) {
        stopAndReportError(backref, RegExpBundle.message("error.group.reference.not.allowed.inside.lookbehind"));
      }
    }
###END###
    public void visitRegExpPattern(RegExpPattern pattern) {
      if (mySupport != RegExpLanguageHost.Lookbehind.FIXED_LENGTH_ALTERNATION) {
        super.visitRegExpPattern(pattern);
        return;
      }
      final int length = myLength;
      int branchLength = -1;
      final RegExpBranch[] branches = pattern.getBranches();
      for (RegExpBranch branch : branches) {
        myLength = 0;
        super.visitRegExpBranch(branch);
        if (branchLength == -1) {
          branchLength = myLength;
        } else if (branchLength != myLength) {
          stopAndReportError(pattern,
                             RegExpBundle.message("error.alternation.alternatives.needs.to.have.the.same.length.inside.lookbehind"));
          return;
        }
      }
      myLength = length + branchLength;
    }
###END###
    public void visitRegExpClosure(RegExpClosure closure) {
      if (mySupport == RegExpLanguageHost.Lookbehind.FULL) {
        return;
      }
      final RegExpQuantifier quantifier = closure.getQuantifier();
      if (quantifier.isCounted()) {
        if (mySupport == RegExpLanguageHost.Lookbehind.FIXED_LENGTH_ALTERNATION ||
          mySupport == RegExpLanguageHost.Lookbehind.VARIABLE_LENGTH_ALTERNATION) {
          final RegExpNumber minElement = quantifier.getMin();
          final RegExpNumber maxElement = quantifier.getMax();
          if (minElement != null && maxElement != null) {
            final Number min = minElement.getValue();
            if (min == null) {
              myStop = true;
              return;
            }
            final Number max = maxElement.getValue();
            if (min.equals(max)) {
              final int length = myLength;
              myLength = 0;
              final RegExpAtom atom = closure.getAtom();
              atom.accept(this);
              final int atomLength = myLength;
              myLength = length + (atomLength * min.intValue());
              return;
            }
          }
          stopAndReportError(quantifier,
                             RegExpBundle.message("error.unequal.min.and.max.in.counted.quantifier.not.allowed.inside.lookbehind"));
        }
      }
      else {
        final ASTNode token = quantifier.getToken();
        assert token != null;
        if (token.getElementType().equals(RegExpTT.QUEST) && mySupport == RegExpLanguageHost.Lookbehind.FINITE_REPETITION) {
          return;
        }
        stopAndReportError(quantifier, RegExpBundle.message("error.0.repetition.not.allowed.inside.lookbehind", quantifier.getText()));
      }
    }
###END###
    public void visitRegExpNamedGroupRef(RegExpNamedGroupRef groupRef) {
      super.visitRegExpNamedGroupRef(groupRef);
      if (mySupport != RegExpLanguageHost.Lookbehind.FULL) {
        stopAndReportError(groupRef, RegExpBundle.message("error.named.group.reference.not.allowed.inside.lookbehind"));
      }
    }
###END###
    public void visitRegExpConditional(RegExpConditional conditional) {
      super.visitRegExpConditional(conditional);
      if (mySupport != RegExpLanguageHost.Lookbehind.FULL) {
        stopAndReportError(conditional, RegExpBundle.message("error.conditional.group.reference.not.allowed.inside.lookbehind"));
      }
    }
###END###
    public void visitPosixBracketExpression(RegExpPosixBracketExpression posixBracketExpression) {
      super.visitPosixBracketExpression(posixBracketExpression);
      myLength++;
    }
###END###
    public void stopAndReportError(RegExpElement element, @NotNull @Nls String message) {
      myHolder.newAnnotation(HighlightSeverity.ERROR, message).range(element).create();
      myStop = true;
    }
###END###
    public void visitRegExpElement(RegExpElement element) {
        element.acceptChildren(this);
    }
###END###
    public void visitRegExpElement(RegExpElement element) {
        visitElement(element);
    }
###END###
    public void visitRegExpChar(RegExpChar ch) {
        visitRegExpElement(ch);
    }
###END###
    public void visitRegExpCharRange(RegExpCharRange range) {
        visitRegExpElement(range);
    }
###END###
    public void visitSimpleClass(RegExpSimpleClass simpleClass) {
        visitRegExpElement(simpleClass);
    }
###END###
    public void visitRegExpClass(RegExpClass regExpClass) {
        visitRegExpElement(regExpClass);
    }
###END###
    public void visitRegExpGroup(RegExpGroup group) {
        visitRegExpElement(group);
    }
###END###
    public void visitRegExpOptions(RegExpOptions options) {
        visitRegExpElement(options);
    }
###END###
    public void visitRegExpProperty(RegExpProperty property) {
        visitRegExpElement(property);
    }
###END###
    public void visitRegExpNamedCharacter(RegExpNamedCharacter namedCharacter) {
        visitRegExpChar(namedCharacter);
    }
###END###
    public void visitRegExpBranch(RegExpBranch branch) {
        visitRegExpElement(branch);
    }
###END###
    public void visitRegExpPattern(RegExpPattern pattern) {
        visitRegExpElement(pattern);
    }
###END###
    public void visitRegExpBackref(RegExpBackref backref) {
        visitRegExpElement(backref);
    }
###END###
    public void visitRegExpClosure(RegExpClosure closure) {
        visitRegExpElement(closure);
    }
###END###
    public void visitRegExpQuantifier(RegExpQuantifier quantifier) {
        visitRegExpElement(quantifier);
    }
###END###
    public void visitRegExpBoundary(RegExpBoundary boundary) {
        visitRegExpElement(boundary);
    }
###END###
    public void visitRegExpSetOptions(RegExpSetOptions options) {
        visitRegExpElement(options);
    }
###END###
    public void visitRegExpIntersection(RegExpIntersection intersection) {
        visitRegExpElement(intersection);
    }
###END###
    public void visitRegExpNamedGroupRef(RegExpNamedGroupRef groupRef) {
        visitRegExpElement(groupRef);
    }
###END###
    public void visitRegExpConditional(RegExpConditional conditional) {
        visitRegExpElement(conditional);
    }
###END###
    public void visitPosixBracketExpression(RegExpPosixBracketExpression posixBracketExpression) {
        visitRegExpElement(posixBracketExpression);
    }
###END###
    public void visitRegExpNumber(RegExpNumber number) {
        visitRegExpElement(number);
    }
###END###
    public void accept(RegExpElementVisitor visitor) {
        visitor.visitRegExpQuantifier(this);
    }
###END###
    public boolean isCounted() {
        return getNode().getFirstChildNode().getElementType() == RegExpTT.LBRACE;
    }
###END###
    public ASTNode getToken() {
        final ASTNode node = getNode().getFirstChildNode();
        final IElementType type = node.getElementType();
        if (type == RegExpTT.LBRACE) {
            return null;
        }
        return node;
    }
###END###
    public RegExpNumber getMin() {
        final ASTNode[] nodes = getNode().getChildren(TOKENS);
        if (nodes.length == 0 || nodes[0].getElementType() != RegExpElementTypes.NUMBER) {
            return null;
        }
        return (RegExpNumber)nodes[0].getPsi();
    }
###END###
    public RegExpNumber getMax() {
        final ASTNode[] nodes = getNode().getChildren(TOKENS);
        if (nodes.length == 0) {
            return null;
        }
        final ASTNode node = nodes[nodes.length - 1];
        if (node.getElementType() != RegExpElementTypes.NUMBER) {
            return null;
        }
        return (RegExpNumber)node.getPsi();
    }
###END###
    public ASTNode getModifier() {
        final ASTNode[] nodes = getNode().getChildren(RegExpTT.QUANTIFIERS);
        if (nodes.length > 1) {
            final ASTNode node = nodes[1];
            final IElementType type = node.getElementType();
            if (type == RegExpTT.QUEST || type == RegExpTT.PLUS) {
                return node;
            }
        }
        return null;
    }
###END###
    public boolean isReluctant() {
        final ASTNode modifier = getModifier();
        return modifier != null && modifier.getElementType() == RegExpTT.QUEST;
    }
###END###
    public boolean isPossessive() {
        final ASTNode modifier = getModifier();
        return modifier != null && modifier.getElementType() == RegExpTT.PLUS;
    }
###END###
  public void accept(RegExpElementVisitor visitor) {
    visitor.visitRegExpConditional(this);
  }
###END###
  public RegExpAtom getCondition() {
    final PsiElement sibling = getFirstChild().getNextSibling();
    if (!(sibling instanceof RegExpBackref) && !(sibling instanceof RegExpNamedGroupRef) && !(sibling instanceof RegExpGroup)) {
      return null;
    }
    return (RegExpAtom)sibling;
  }
###END###
    public void accept(RegExpElementVisitor visitor) {
        visitor.visitRegExpClosure(this);
    }
###END###
    public RegExpQuantifier getQuantifier() {
        final ASTNode node = getNode().findChildByType(RegExpElementTypes.QUANTIFIER);
        assert node != null;
        return (RegExpQuantifier)node.getPsi();
    }
###END###
    public RegExpAtom getAtom() {
        final RegExpAtom atom = PsiTreeUtil.getChildOfType(this, RegExpAtom.class);
        assert atom != null;
        return atom;
    }
###END###
    public RegExpChar getFrom() {
        return (RegExpChar)getFirstChild();
    }
###END###
    public RegExpChar getTo() {
        final PsiElement child = getLastChild();
        return child instanceof RegExpChar ? (RegExpChar)child : null;
    }
###END###
    public void accept(RegExpElementVisitor visitor) {
        visitor.visitRegExpCharRange(this);
    }
###END###
    public RegExpOptions getOnOptions() {
        final ASTNode[] nodes = getNode().getChildren(TokenSet.create(RegExpElementTypes.OPTIONS));
        for (ASTNode node : nodes) {
            if (!node.textContains('-')) {
                return (RegExpOptions)node.getPsi();
            }
        }
        return null;
    }
###END###
    public RegExpOptions getOffOptions() {
        final ASTNode[] nodes = getNode().getChildren(TokenSet.create(RegExpElementTypes.OPTIONS));
        for (ASTNode node : nodes) {
            if (node.textContains('-')) {
                return (RegExpOptions)node.getPsi();
            }
        }
        return null;
    }
###END###
    public void accept(RegExpElementVisitor visitor) {
        visitor.visitRegExpSetOptions(this);
    }
###END###
    public void accept(RegExpElementVisitor visitor) {
        visitor.visitRegExpOptions(this);
    }
###END###
    public boolean isSet(char option) {
        return getUnescapedText().indexOf(option) >= 0;
    }
###END###
  public Number getValue() {
    return RegExpLanguageHosts.getInstance().getQuantifierValue(this);
  }
###END###
  public void accept(RegExpElementVisitor visitor) {
    visitor.visitRegExpNumber(this);
  }
###END###
  public void accept(RegExpElementVisitor visitor) {
    visitor.visitRegExpGroup(this);
  }
###END###
  public @NotNull RegExpPattern getPattern() {
    final ASTNode node = getNode().findChildByType(RegExpElementTypes.PATTERN);
    assert node != null;
    return (RegExpPattern)node.getPsi();
  }
###END###
  public boolean isCapturing() {
    final Type type = getType();
    return type == Type.CAPTURING_GROUP || type == Type.NAMED_GROUP || type == Type.QUOTED_NAMED_GROUP || type == Type.PYTHON_NAMED_GROUP;
  }
###END###
  public boolean isAnyNamedGroup() {
    final Type type = getType();
    return type == Type.NAMED_GROUP || type == Type.QUOTED_NAMED_GROUP || type == Type.PYTHON_NAMED_GROUP;
  }
###END###
  public Type getType() {
    final IElementType elementType = getNode().getFirstChildNode().getElementType();
    if (elementType == RegExpTT.GROUP_BEGIN) {
      return Type.CAPTURING_GROUP;
    }
    else if (elementType == RegExpTT.RUBY_NAMED_GROUP) {
      return Type.NAMED_GROUP;
    }
    else if (elementType == RegExpTT.PYTHON_NAMED_GROUP) {
      return Type.PYTHON_NAMED_GROUP;
    }
    else if (elementType == RegExpTT.RUBY_QUOTED_NAMED_GROUP) {
      return Type.QUOTED_NAMED_GROUP;
    }
    else if (elementType == RegExpTT.ATOMIC_GROUP) {
      return Type.ATOMIC;
    }
    else if (elementType == RegExpTT.NON_CAPT_GROUP) {
      return Type.NON_CAPTURING;
    }
    else if (elementType == RegExpTT.SET_OPTIONS) {
      return Type.OPTIONS;
    }
    else if (elementType == RegExpTT.POS_LOOKAHEAD) {
      return Type.POSITIVE_LOOKAHEAD;
    }
    else if (elementType == RegExpTT.NEG_LOOKAHEAD) {
      return Type.NEGATIVE_LOOKAHEAD;
    }
    else if (elementType == RegExpTT.POS_LOOKBEHIND) {
      return Type.POSITIVE_LOOKBEHIND;
    }
    else if (elementType == RegExpTT.NEG_LOOKBEHIND) {
      return Type.NEGATIVE_LOOKBEHIND;
    }
    else if (elementType == RegExpTT.PCRE_BRANCH_RESET) {
      return Type.PCRE_BRANCH_RESET;
    }
    throw new AssertionError();
  }
###END###
  public static boolean isPcreConditionalGroup(ASTNode node) {
    return node != null && node.findChildByType(RegExpTT.PCRE_CONDITIONS) != null;
  }
###END###
  public static boolean isPcreDefine(ASTNode node) {
    return node != null && node.findChildByType(RegExpTT.PCRE_DEFINE) != null;
  }
###END###
  public String getGroupName() {
    final ASTNode nameNode = getNode().findChildByType(RegExpTT.NAME);
    return nameNode != null ? nameNode.getText() : null;
  }
###END###
  public String getName() {
    return getGroupName();
  }
###END###
  public PsiElement setName(@NonNls @NotNull String name) throws IncorrectOperationException {
    throw new IncorrectOperationException();
  }
###END###
  public int getTextOffset() {
    return getFirstChild().getNextSibling().getTextOffset();
  }
###END###
    public int getIndex() {
        return Integer.parseInt(getIndexNumberText());
    }
###END###
    private String getIndexNumberText() {
        final ASTNode node = getNode().findChildByType(RegExpTT.NUMBER);
        if (node != null) {
            return node.getText();
        }
        final String s = getUnescapedText();
        boolean pcreBackReference = s.charAt(1) == 'g';
        boolean pcreNumberedGroup = s.startsWith("(?");
        assert s.charAt(0) == '\\' || pcreNumberedGroup;
        return pcreBackReference ? getPcreBackrefIndexNumberText(s.substring(2)) :
               pcreNumberedGroup ? getPcreNumberedGroupIndexNumberText(s.substring(2)) :
               s.substring(1);
    }
###END###
    private static String getPcreNumberedGroupIndexNumberText(String s) {
      return trimEnd(s, ")");
    }
###END###
    private static String getPcreBackrefIndexNumberText(String s) {
        return trimEnd(trimStart(s, "{"), "}");
    }
###END###
    public void accept(RegExpElementVisitor visitor) {
        visitor.visitRegExpBackref(this);
    }
###END###
    public RegExpGroup resolve() {
        return resolve(getIndex(), getContainingFile());
    }
###END###
    static RegExpGroup resolve(int index, PsiFile file) {
        if (index < 0) {
            return resolveRelativeGroup(Math.abs(index), file);
        }

        return SyntaxTraverser.psiTraverser(file)
          .filter(RegExpGroup.class)
          .filter(RegExpGroup::isCapturing)
          .skip(index - 1)
          .first();
    }
###END###
    private static RegExpGroup resolveRelativeGroup(int index, PsiFile file) {
        List<RegExpGroup> groups = SyntaxTraverser.psiTraverser(file)
          .filter(RegExpGroup.class)
          .filter(RegExpGroup::isCapturing)
          .toList();
        return index <= groups.size() ? groups.get(groups.size() - index) : null;
    }
###END###
    public PsiReference getReference() {
        return new PsiReference() {
            @Override
            @NotNull
            public PsiElement getElement() {
                return RegExpBackrefImpl.this;
            }

            @Override
            @NotNull
            public TextRange getRangeInElement() {
                return TextRange.from(0, getElement().getTextLength());
            }

            @Override
            @NotNull
            public String getCanonicalText() {
                return getElement().getText();
            }

            @Override
            public PsiElement handleElementRename(@NotNull String newElementName) throws IncorrectOperationException {
                throw new IncorrectOperationException();
            }

            @Override
            public PsiElement bindToElement(@NotNull PsiElement element) throws IncorrectOperationException {
                throw new IncorrectOperationException();
            }

            @Override
            public boolean isReferenceTo(@NotNull PsiElement element) {
                return Comparing.equal(element, resolve());
            }

            @Override
            public boolean isSoft() {
                return false;
            }

            @Override
            public PsiElement resolve() {
                return RegExpBackrefImpl.this.resolve();
            }
        };
    }
###END###
            public PsiElement getElement() {
                return RegExpBackrefImpl.this;
            }
###END###
            public TextRange getRangeInElement() {
                return TextRange.from(0, getElement().getTextLength());
            }
###END###
            public String getCanonicalText() {
                return getElement().getText();
            }
###END###
            public PsiElement handleElementRename(@NotNull String newElementName) throws IncorrectOperationException {
                throw new IncorrectOperationException();
            }
###END###
            public PsiElement bindToElement(@NotNull PsiElement element) throws IncorrectOperationException {
                throw new IncorrectOperationException();
            }
###END###
            public boolean isReferenceTo(@NotNull PsiElement element) {
                return Comparing.equal(element, resolve());
            }
###END###
            public boolean isSoft() {
                return false;
            }
###END###
            public PsiElement resolve() {
                return RegExpBackrefImpl.this.resolve();
            }
###END###
  public static boolean areElementsEquivalent(RegExpElement element1, RegExpElement element2) {
    if (element1 == null) {
      return element2 == null;
    }
    if (element1.getClass() != element2.getClass()) {
      return false;
    }
    if (element1 instanceof RegExpChar) {
      return areCharsEquivalent((RegExpChar)element1, (RegExpChar)element2);
    }
    else if (element1 instanceof RegExpBranch) {
      return areBranchesEquivalent((RegExpBranch)element1, (RegExpBranch)element2);
    }
    else if (element1 instanceof RegExpClass) {
      return areClassesEquivalent((RegExpClass)element1, (RegExpClass)element2);
    }
    else if (element1 instanceof RegExpCharRange) {
      return areCharRangesEquivalent((RegExpCharRange)element1, (RegExpCharRange)element2);
    }
    else if (element1 instanceof RegExpClosure) {
      return areClosuresEquivalent((RegExpClosure)element1, (RegExpClosure)element2);
    }
    else if (element1 instanceof RegExpGroup) {
      return areGroupsEquivalent((RegExpGroup)element1, (RegExpGroup)element2);
    }
    else if (element1 instanceof RegExpIntersection) {
      return areIntersectionsEquivalent((RegExpIntersection)element1, (RegExpIntersection)element2);
    }
    else if (element1 instanceof RegExpNamedGroupRef) {
      return areNamedGroupRefsEquivalent((RegExpNamedGroupRef)element1, (RegExpNamedGroupRef)element2);
    }
    else if (element1 instanceof RegExpNumber) {
      return areNumbersEquivalent((RegExpNumber)element1, (RegExpNumber)element2);
    }
    else if (element1 instanceof RegExpOptions) {
      return areOptionsEquivalent((RegExpOptions)element1, (RegExpOptions)element2);
    }
    else if (element1 instanceof RegExpPattern) {
      return arePatternsEquivalent((RegExpPattern)element1, (RegExpPattern)element2);
    }
    else if (element1 instanceof RegExpSetOptions) {
      return areSetOptionsEquivalent((RegExpSetOptions)element1, (RegExpSetOptions)element2);
    }
    return element1.textMatches(element2);
  }
###END###
  private static boolean areSetOptionsEquivalent(RegExpSetOptions setOptions1, RegExpSetOptions setOptions2) {
    return areOptionsEquivalent(setOptions1.getOnOptions(), setOptions2.getOnOptions()) &&
           areOptionsEquivalent(setOptions1.getOffOptions(), setOptions2.getOffOptions());
  }
###END###
  private static boolean areOptionsEquivalent(RegExpOptions options1, RegExpOptions options2) {
    return options1 == null ? options2 == null : options2 != null && StringUtil.containsAnyChar(options1.getText(), options2.getText());
  }
###END###
  private static boolean areNamedGroupRefsEquivalent(RegExpNamedGroupRef namedGroupRef1, RegExpNamedGroupRef namedGroupRef2) {
    final String name = namedGroupRef1.getGroupName();
    return name != null && name.equals(namedGroupRef2.getGroupName());
  }
###END###
  private static boolean areIntersectionsEquivalent(RegExpIntersection intersection1, RegExpIntersection intersection2) {
    return areElementArraysEquivalent(intersection1.getOperands(), intersection2.getOperands(), true);
  }
###END###
  private static boolean areGroupsEquivalent(RegExpGroup group1, RegExpGroup group2) {
    return group1.getType() == group2.getType() && arePatternsEquivalent(group1.getPattern(), group2.getPattern());
  }
###END###
  private static boolean arePatternsEquivalent(RegExpPattern pattern1, RegExpPattern pattern2) {
    return pattern1 == null ?
           pattern2 == null :
           pattern2 != null && areElementArraysEquivalent(pattern1.getBranches(), pattern2.getBranches(), true);
  }
###END###
  private static boolean areClosuresEquivalent(RegExpClosure element1, RegExpClosure element2) {
    return areElementsEquivalent(element1.getAtom(), element2.getAtom()) &&
      areQuantifiersEquivalent(element1.getQuantifier(), element2.getQuantifier());
  }
###END###
  private static boolean areQuantifiersEquivalent(RegExpQuantifier quantifier1, RegExpQuantifier quantifier2) {
    if (quantifier1.isCounted()) {
      return quantifier2.isCounted() &&
             areNumbersEquivalent(quantifier1.getMin(), quantifier2.getMin()) &&
             areNumbersEquivalent(quantifier1.getMax(), quantifier2.getMax());
    }
    return quantifier1.textMatches(quantifier2);
  }
###END###
  private static boolean areNumbersEquivalent(RegExpNumber number1, RegExpNumber number2) {
    if (number1 == null) {
      return number2 == null;
    }
    else if (number2 == null) {
      return false;
    }
    final Number value1 = number1.getValue();
    final Number value2 = number2.getValue();
    return value1 != null && value1.equals(value2);
  }
###END###
  private static boolean areCharRangesEquivalent(RegExpCharRange charRange1, RegExpCharRange charRange2) {
    return areCharsEquivalent(charRange1.getFrom(), charRange2.getFrom()) && areCharsEquivalent(charRange1.getTo(), charRange2.getTo());
  }
###END###
  private static boolean areClassesEquivalent(RegExpClass aClass1, RegExpClass aClass2) {
    return aClass1.isNegated() == aClass2.isNegated() && areElementArraysEquivalent(aClass1.getElements(), aClass2.getElements(), true);
  }
###END###
  private static boolean areBranchesEquivalent(RegExpBranch branch1, RegExpBranch branch2) {
    return areElementArraysEquivalent(branch1.getAtoms(), branch2.getAtoms(), false);
  }
###END###
  private static boolean areElementArraysEquivalent(RegExpElement[] elements1, RegExpElement[] elements2, boolean inAnyOrder) {
    if (elements1.length != elements2.length) {
      return false;
    }
    if (inAnyOrder) {
      Arrays.sort(elements1, TEXT_COMPARATOR);
      Arrays.sort(elements2, TEXT_COMPARATOR);
    }
    return ArrayUtil.areEqual(elements1, elements2, RegExpEquivalenceChecker::areElementsEquivalent);
  }
###END###
  private static boolean areCharsEquivalent(RegExpChar aChar1, RegExpChar aChar2) {
    return aChar1 == null ? aChar2 == null : aChar2 != null && aChar1.getValue() == aChar2.getValue();
  }
###END###
  public @NotNull PsiElementVisitor buildVisitor(@NotNull ProblemsHolder holder, boolean isOnTheFly) {
    return new SuspiciousBackrefVisitor(holder);
  }
###END###
    public void visitRegExpBackref(RegExpBackref backref) {
      super.visitRegExpBackref(backref);
      final RegExpGroup target = backref.resolve();
      if (target == null) {
        return;
      }
      final RegExpBranch branch = PsiTreeUtil.getParentOfType(target, RegExpBranch.class);
      if (!PsiTreeUtil.isAncestor(branch, backref, true)) {
        final String message =
          RegExpBundle.message("inspection.warning.group.back.reference.are.in.different.branches", backref.getIndex());
        myHolder.registerProblem(backref, message);
      }
      else if (target.getTextOffset() > backref.getTextOffset()) {
        final String message = RegExpBundle.message("inspection.warning.group.defined.after.back.reference", backref.getIndex());
        myHolder.registerProblem(backref, message);
      }
    }
###END###
    public void visitRegExpNamedGroupRef(RegExpNamedGroupRef groupRef) {
      super.visitRegExpNamedGroupRef(groupRef);
      final RegExpGroup target = groupRef.resolve();
      if (target == null) {
        return;
      }
      final RegExpBranch branch = PsiTreeUtil.getParentOfType(target, RegExpBranch.class);
      if (!PsiTreeUtil.isAncestor(branch, groupRef, true) && !isPcreCondition(branch)) {
        final String message =
          RegExpBundle.message("inspection.warning.group.back.reference.are.in.different.branches", groupRef.getGroupName());
        myHolder.registerProblem(groupRef, message);
      }
      else if (target.getTextOffset() > groupRef.getTextOffset()) {
        final String message = RegExpBundle.message("inspection.warning.group.defined.after.back.reference", groupRef.getGroupName());
        myHolder.registerProblem(groupRef, message);
      }
    }
###END###
    private static boolean isPcreCondition(RegExpBranch branch) {
      if (branch == null) return false;
      if (branch.getParent() instanceof RegExpConditional) {
        RegExpGroup groupCondition = ObjectUtils.tryCast(((RegExpConditional)branch.getParent()).getCondition(), RegExpGroup.class);
        return groupCondition != null && RegExpGroupImpl.isPcreConditionalGroup(groupCondition.getNode());
      }
      return false;
    }
###END###
    public void visitRegExpBackref(RegExpBackref backref) {
      super.visitRegExpBackref(backref);
      final RegExpGroup target = backref.resolve();
      if (target == null) {
        return;
      }
      final RegExpBranch branch = PsiTreeUtil.getParentOfType(target, RegExpBranch.class);
      if (!PsiTreeUtil.isAncestor(branch, backref, true)) {
        final String message =
          RegExpBundle.message("inspection.warning.group.back.reference.are.in.different.branches", backref.getIndex());
        myHolder.registerProblem(backref, message);
      }
      else if (target.getTextOffset() > backref.getTextOffset()) {
        final String message = RegExpBundle.message("inspection.warning.group.defined.after.back.reference", backref.getIndex());
        myHolder.registerProblem(backref, message);
      }
    }
###END###
    public void visitRegExpNamedGroupRef(RegExpNamedGroupRef groupRef) {
      super.visitRegExpNamedGroupRef(groupRef);
      final RegExpGroup target = groupRef.resolve();
      if (target == null) {
        return;
      }
      final RegExpBranch branch = PsiTreeUtil.getParentOfType(target, RegExpBranch.class);
      if (!PsiTreeUtil.isAncestor(branch, groupRef, true) && !isPcreCondition(branch)) {
        final String message =
          RegExpBundle.message("inspection.warning.group.back.reference.are.in.different.branches", groupRef.getGroupName());
        myHolder.registerProblem(groupRef, message);
      }
      else if (target.getTextOffset() > groupRef.getTextOffset()) {
        final String message = RegExpBundle.message("inspection.warning.group.defined.after.back.reference", groupRef.getGroupName());
        myHolder.registerProblem(groupRef, message);
      }
    }
###END###
    private static boolean isPcreCondition(RegExpBranch branch) {
      if (branch == null) return false;
      if (branch.getParent() instanceof RegExpConditional) {
        RegExpGroup groupCondition = ObjectUtils.tryCast(((RegExpConditional)branch.getParent()).getCondition(), RegExpGroup.class);
        return groupCondition != null && RegExpGroupImpl.isPcreConditionalGroup(groupCondition.getNode());
      }
      return false;
    }
###END###
